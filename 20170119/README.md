## 20170119

## 클래스와 객체, 메소드     
* 클래스는 같은 종류의 집단에 속하는 속성(프로퍼티)과 행위(메소드)를 정의한 것.   
* 객체는 클래스의 인스턴스임…인스턴스는 실제로 메모리 상에 할당된 것을 의미함.   
* 메소드 클래스로부터 생성된 객체를 사용하는 방법으로서 객체에 명령을 내리는 메시지…객체간의 통신은 메시지를 통해 이뤄짐

## 상속    
### 새로운 클래스가 기존의 클래스의 자료와 연산을 이용할 수 있게 하는 기능
### 기존에 구현되어 있는 클래스를 확장, 변형 
### 부모 (super, parent class) 자식(sub, child class) 관계...즉, 자식의 기능이 부모의 기능과 같거나 혹은 더 많다.
 
* 워리어와 위저드의 공통점은?    
* 워리어와 위저드의 중복되는 프로퍼티들을 왜 다 하나하나 수정해야 하지?    
* **그래서 워리어와 위저드를 계층구조로 묶어보자…”상속의 기본 발상”.**   
* 클래스의 상속은 새로은 클래스가 기존 클래스의 자료와 연산을 이용할 수 있게 하는 기능.   
* 부모 클래스와 자식 클래스.   
* 프로그래밍에서 부모 클래스는 **“무조건 하나”.**   
* 자식클래스는 부모 클래스가 갖고있지 않던 것을 가질 수 있음

### NSObject?    
* 모든 것의 최상위 부모 클래스…오브젝티브 C에서 가장 기본이 되는 클래스…”오브젝티브 씨 언어의 최고존엄 클래스”.   
* NSObject를 상속한 덕분에 alloc, init과 같은 메소드를 활용 가능했음….   
* 오브젝티브 씨의 모든 클래스는 NSObject를 상속 받아야 함.   
* NSObject를 상속받은 수많은 클래스가 있다…이 위계관계를 지켜가면서 프로퍼티, 메소드를 활용해야 충돌이 일어나지 않는다… **“NSObject Hireacy"**

### 클래스의 상속.   
* 서브클래싱 이라고 함.   
* 기존 구현되어 있던 클래스를 확장 및 변형.   
* 상속 할수록 더 확장되는 구조 —->즉 자식이 더 많은 기능을 가질 가능성이 크다.   
* 부모클래스는 슈퍼클래스, 패런츠 클래스, 자식클래스는 서브클래스, 차일드 클래스로 표현

		import “부모클래스.h”    
		@ interface 나자신클래스 : 부모클래스.   

### 상속에서의 메소드 공유 및 다형성.   
* 부모클래스에 있는 메소드…상속받은 자식클래스에선 같은 메소드라도 자식클래스가. “다른 행동”을 하게 할 수도 있다….   
* **“재정의” 를 의미함 = Override**

## 재정의   

* 부모클래스에게서 물려받은 성질을 그대로 사용하지 않고, 자식클래스에게 맞는 형태. 또는 행위로 변경하여 사용할 수 있는 기능.   


> 중복정의? (Overload)… 
> 재정의처럼  객체지향언어의 다형성의 또다른 모습….   
“중복정의는 함수에서…매개변수만 다른 것…어떤함수는 이름만 받고, 어떤 함수는 이름과. 나이를 받고, 또 다른 함수는 이름 나이 성별까지…즉 받는 파라미터의 성질 까지 다른. 것”.   
그러나 오브젝티브 씨는 중복정의를 지원하지 않음…왜냐하면 파라미터 앞에 항상. 외부이름이 붙으므로…즉 “파라미터가 바뀌면 전체 메소드 이름이 바뀌는 것…즉 똑같은. 이름에 타입과 변수 이름만 바뀌는 것은 오브젝티브 씨에서 불가함”

### 셀프와 슈퍼.   
* self : 객체 스스로 자신을 지칭할 때 사용하는. 키워드.   
* super : 객체의 부모 클래스에 접근할 때 사용.   
* 셀프와 슈퍼는  main.m 에서는 구현, 선언할 수 없다…써봤자 선언된 게 없으니. 컴파일러가 뭔지 못알아듣는다…결국 각 클래스의 m파일에 가서 기능을 구현해줘야. 한다.  

 
> 슈퍼 호출   
`[super eat];`    

## 은닉화.   
* “숨기는 것” “보안이 목적”.   
* “만일 엠파일만 있어서, 임포트를 엠파일만 해야 한다면, 하부 클래스나 다른 파일이 엠파일에 있는 모든 코드를 다 볼 수 있을것”.   
* “궁극적으로, 헤더파일과 엠파일이 나눠져 있는 것은 객체지향과 은닉화가 목적…공개해도 되는건 헤더파일에 올려놓고, 공개하기 싫은건 엠파일에 몰아넣겠다는 것이 가장 간단한 개념…”    
* “굳이 안 보여줘도 되는것을 협업하는 사람이 봐서, 그 사람이 실수를 하게 되는 것 조차 막겠다는 발상”.    
* “별도로, 오브젝티브씨는 디컴파일…즉 남의 라이브러리를 까보는 것이 불가능함…자바는 무료로 나와서 거의 오픈으로 쓰라고 해놓 것이라 디컴파일이 가능함”.   

* 헤더의 프로퍼티를 구현파일(엠파일)로 옮겨올 수 은닉화 가능.   
* 오브젝티브씨의 카테고리 기능으로 은닉화 가능     

> 카테고리화의 예.   
Ex. NSString…애플이 만든 것이라 모든 것들이 은닉되어있음…”쓰기만 가능하고 수정이 불가능한”…그래서 애플은 수정은 못하더라도 확장은 가능하게 해놓음…이것이 바로 카테고리 개념…”NSString + ABCDE” 와 같은 식으로….   
Ex2. 인터넷에서 다운받기+UIView 기능을 쓰게끔 카테고리화 되어 있으면 원래는 인터넷에서 다운받기 메소드를 실행하고, 이어서 UIView 메소드를 실행하게끔 코드를 2줄 써야 할 것을 코드를 1줄을 써도 된다

### m파일을 활용한 은닉화    
* m파일에 @interface 클래스명 ().   
* 헤더파일의 프로퍼티 or 숨기고 싶은 메소드 구현 코드를 m파일의 인터페이스-클래스명밑에 작성        
* 상속의 경우 자식클래스는 부모클래스가 은닉한(엠파일에 숨긴 프로퍼티) 상속해올 수 없음…만일 은닉화 할때 메소드도 새로 만들어서 넣는다면, 이 새로 만든 메소드는 헤더파일에 적지 않아도, 구동은 된다.     
* “필요한 정보만 보여주고 필요없는 정보는 숨기도록”.   
* “또한 너무 많은 정보를 주는 대신 필요한 정보만 제공하면 보이는 것만 인지하고 연산하면 되므로…”     

		HighSchoolStudent.m   
		@interface HighSchoolStudent ()    

		@property age;    
		- (id) eat{    
		NSUlog(@“~~i%~~lu%~~”, A, B);    
		return nil;    
		}    
		@end   

* 상기 은닉화에서, 메소드는 메인.m파일에 작성해도 에러가 뜬다…왜냐하면 m파일은 은닉화된 메소드가 존재한다는 사실을 “알수 없으므로”    
* 또한 은닉화 된 프로퍼티는 상속되지 않는다….   
* 프로퍼티가 상속화 되려면 헤더파일에 있어야 한다…    

* 부모클래스에서 공개된 것들을 상속받은 경우, 자식클래스가 상속받은 것들을 은닉화 할 수 는 없음….   

> 데이터를 바꾸는 것은 아니더라도 열람은 해야 하는 경우는?    
`(readonly) (readwrite) 옵션 설정…`    

> Ex. Name 프로퍼티를. Readonly로 설정하면 main파일에서 다른 이름을 적으려고 하면 에러가 뜸