## 20170117


### 콘솔 프로젝트 파일 생성…커맨드라인 툴    
* 클래스 객체 기능 구현…    
* 파일—>new—>코코아파일

### 새 프로젝트 만들기    
* 명명법…첫 글자에 숫자면 안됨…시스템 예약어는 안됨…

`import <Foundation/Foundation.h>`    
`@interface Person : NSObject`    
`@end`


* 생성하면 파일이 두 개가 생김…오브젝티브씨는 파일이 두개, 스위프트는 하나가 생김
하나는 .h…즉 헤더파일…헤더에 들어갈 내용이 포함되는 파일…    
* m…엠파일에는 구현될 내용이 들어감…

* 헤더파일의 내용…

`import <Foundation/Foundation.h>  “클래스이름”` 
`@interface Person : NSObject  “상속을 받은 곳”`    
`@end   “끝:`    

* “인터페이스와 엔드 사이에서 객체의 프로퍼티, 메소드를 작성해서 정의헤야 함    
---- >즉 클래스와 관계는 밀접한 관계가 있다…클래스 안에 만드는 것들은 객체를 위해 만드는 것임    

* 프로퍼티 : 객체가 가질 수 있는 특징 상태 등의 “값” …즉 속성…    
* 메소드 : 객체가 수행할 수 있는 동작 또는 “기능”

### 프로퍼티의 정의    
* 사람의 특징?     
`이름 /. 성별(남,여) /. 피부색 / 직업 / 국적 / 머리색 /`    
* 정의    
`@property <data type> <property name>;`    
* `@property id name;`    
* name의 역할은 “저장하는 공간” 

### 프로퍼티 정의 실습    
* 사람의 클래스 및 프로퍼티 


`import <Foundation/Foundation.h>`    
@interface Person : NSObject    
@property id name;    
@property id gender;    
@property id age;     
@property id job;    
@property id birthDate;    
@property id mobileNumber;    
//사람의 클래스를 정의해보기...프로퍼티 : 이름, 성별, 나이, 직업, 생일, 핸드폰번호    

### 메소드 정의    
* 정의    
- (<반환 타입>)<메소드 이름>;      
* (id)methodName;    
* 사람이 할 수 있는 행위는 무엇이 있나?    
* 메소드와 프로퍼티는 내가 어떤 값으로 데이터들을 분류할 수 있는지를 생각해보면서 만들어 봐야 함    

## 내 맘대로 클래스 생성        
* 메소드는 무조건 “한다”는 개념…명령을 “한다/하지않는다”로 나누는 것이 아님…   
* 예스 노, 무선이다 아니다, 되냐 안되냐 는 프로퍼티에서 잡아주는 것..    
* 클래스를 만드는 것은 추상화를 하는 것…

### 추상화…    
* 사람을 클래스로 만들 때 사람은 다 틀리다…    
* 그러나 사람이 무엇인가 라고 물으면 누구나 사람의 공통적 사항을 뽑아낼 수 있음 = 사람을 추상화 할 수 있음    
* 추상화는 실제 존재하는 사물을 봤을 때 그 사물 하나하나의 특유의 성질이 아닌, 보편적인 성질을 뽑아내는 것…    
* 클래스는 결국 보편적인 성질들을 만들고자 하는 프로그램의 성격, 사용목적 등에 따라 프로그래머가 재량껏 추상화를 거쳐서 작성하는 것임    

## 객체     
* 객체는 클래스가 실질적인 형태로 주기억장치에 생성된 것    
* 클래스를 작성하면 클래스라는 작성 코드는 파일로 저장됨…빌드(컴파일)하면 기계어로 변환이 되고…이 변환된 EXE를 실행하면 프로그램은 프로세스가 된다…그리고 프로세스가 되어야 메모리에 Load 된다…즉 작성한 코드를 읽고, 변환하면 객체가 메모리에 생성되는 것…    

> import?

> * 파일로 생성한 클래스 들의 헤더 파일들을 먼저 임포트 함...임포트 해야 main.m파일에 작성해서 객체로 생성 가능함 
   
* 객체 생성    
`[<클래스이름> alloc];`    
`[Warrior alloc];`     
`[Wizard alloc];`     
`[Person alloc];`      
== 위저드, 퍼슨, 워리어 라는 객체를 만들어라…또 alloc으로 작성하면 같은 객체가 또 생겨남    

* 객체생성+초기화      
**프로그램의 무결성을 위해 하는 것**    
**컴퓨터는 객체를 생성하고 초기화 한 후, 객체가 메모리의 어떤 위치에 있는지 주소값을 알려줌**    
> `[[<클래스이름> alloc] init];`    
코드를 작성하면 클래스를 위해 메모리를 할당하게 됨…할당은 메모리에 객체가 “완전히”들어가는 것이 아닌, 컴퓨터가 “이정도의 용량은 클래스 A의 객체에게 줘야 되는구나”라고 인지하게끔 하는 것…그 다음에 컴퓨터는 “메모리 구역 ㄱ에 클래스 A를 위한 메모리를 할당했다”라며 객체가 메모리의 어떤 위치에 있는지 CPU에게 주소값을 알려주게 됨     
또한 init은 이전에 생성된 객체가 삭제된 후…데이터가 제대로 삭제가 다 안된 상태로 신규 객체가 생성되었을때 같은 메모리 공간에 할당되어 신규 객체와 구 객체의 데이터가 꼬이는 경우를 막기 위한 것임     

### 변수생성    
* 데이터타입*변수이름 = 객체의 주소     
* 생성된객체를 프로그래머가 지속적으로 사용하려면 변수 또는 상수에 담고 있어야 함    
* [[<클래스이름> alloc] init]; 이 “주소값”으로 바뀌는 것    
* 따라서  <클래스이름>*<변수이름> = 객체의 주소       

> Ex. Person *mike = [[Person alloc] init];     


> * “person이라는 객체가 들어갈 mike라는 공간, 즉 변수를 생성한다...첫 번째 객체에는 Mike라는 이름을 붙일 것이다”    
* “오른쪽에 있는 데이터를 왼쪽의 mike에 집어 넣겠다"    
* 마이크는 person의 특성을 담는 바구니, 공간이라고 보면 된다    
* [[Person alloc] init]; 만 쓰면 이는 0x7684A와 같은 데이터로 변하고, 프로그래머는 이 데이터를 불러올 방법이 없다...    
* 따라서 프로그래머는 Person *mike = [[Person alloc] init]; 로 코드를 작성해야 하는 것    
* 노란색 느낌표의 Unuased variable 경고가 뜨는데…이는 변수를 생성했는데 왜 쓰질 않은 것인지를 컴파일러가 물어보는 것…작동이 안된다는 것이 아니라…

* 복수의 객체 생성 시…     
`Person *jun = [[Person alloc] init];`    
`Person *jay = [[Person alloc] init];`    
으로 person 객체를 두개 생성한다면, jun과 jay는 컴퓨터도 두 개의 객체라고 인식한다...즉 문제가 없다          

## 프로퍼티 접근     
* 클래스코드에 객체가 각자 가질 수 있는 상태값으 프로퍼티로 정의해 두는 것   
* Set : 객체를 생성하고 프로퍼티에 값을 설정하는 것

`jun.name = @ "junyoungjee";`

`kim.name = @ "kimjiyoung";`
    
    Person *me = [[Person alloc] init];
    me.name = @ "joo";
    
    Warrior *jack = [[Warrior alloc] init];
    jack.health = @300;
    jack.mana = @10;
    jack.physicalPower = @30;
    jack. magicalPower = @10;
    
    Wizard *rose = [[Wizard alloc] init];
    rose.health = @120;
    rose.mana = @200;
    rose.physicalPower = @10;
    rose.magicalPower = @30;
   
    // jun.name = @ "junyoungjee"; / kim.name = @     
    "kimjiyoung"; 은 각각 준, 김 이라는 객체의 프로퍼티인 name이     
    junyoungjee, kimjiyoung 이라는 의미임     
    //jack과 rose라는 warrior, Wizard 객체가 생성됨과 동시에,    
    각 프로퍼티의 속성값이 부여됨...즉 Set 됨

* Get    
프로퍼티의 값을 가져오는 것     

`NSLog(@"jack의 물리 공격력은 %@이다" ,jack.physicalPower);`    
`NSLog(@"jack의 체력은 %@이고, rose의 체력은 %@이다", jack.health, rose.health);`     
`NSLog(@"jack의 마나는 %@이다" ,jack.mana);`     
`NSLog(@"rose의 마나는 %@이다" ,rose.mana);`    
`NSLog(@"jack의 마법 공격력은 %@이고, rose의 마법 공격력은 %@이다" ,jack.mana, rose.mana);`
    
    
    //Get
    //NSLog(@"jack의 체력은 %@이고, rose의 체력은 %@이다", jack.health, rose.health);    
    //NSLog(@"띄우고 싶은 텍스트 메시지 %@", 객체.프로퍼티, 객체.프로퍼티);

## 메소드 구현          
* 실제로 그 행위를 처리해야 할 일(코드)는 구현파일(.m)의 @implementation과 @end 사이에 구현해 주어야 함     
* 구현은 { }를 쳐준다…”~~한 행위”를 하도록 써주는 것    
* 헤더파일(.h)는 그냥 요약서, 목차와 같고, 엠파일(.m)은 구체적인 행동지침이 적혀 있는 것     
* 엠파일에는 프로그래머 개개인이 Private하게 작성한 코드를 주로 적고, 헤더파일엔 누구나 복사하고 써도 되는 것들을 주로 적는다…      
* 헤더파일에는 - (id) myName;과 같은 메소드의 이름만, 엠파일에는 해당 메소드가 구체적으로 해야 할 일을 적는다     

    	- (id) myName;    
		{     
		NSLog(@"내 이름은 %@입니다", self.name);     
		return nil;      

* “return nil 은 메소드를 호출하는 방법 중 하나로서, 반환이 이렇게 돌아간 다는 것을 보이고자 예제로 그냥 써본 것…nil은 값이 없다는 거이므로”     
* “NSLog 코드 역할은 로그창에 텍스트를 찍어주는 역할…프로그램을 만들었을 시 실제 프로그램을 쓰는 사용자에게는 영향이 없으나 코드를 만드는 개발자에게 텍스트를 띄워줘서 코드가 잘 되는지 확인하는 것…[글이 찍히면 진행이 되었다]고 보면 되는 것”     

> 왜 return nil을 쓰는가?     
“- (<반환 타입>)<메서드 이름>     
이렇게 메서드를 만들 때, 반환할 자료형을(id) 명시했기 때문임.     
- (void)<메서드 이름>     
이렇게 만들면 return을 안해도 됨     
void는 비어있다, 반환할 값이 없다는 것을 의미함."     

* 헤더파일에 있는 것이 엠파일에 없으며 경고가 뜨고, 반대로 엠파일에 있으나 헤더파일에 없으면 경고가 뜨진 않는다     
* 헤더파일은 임포트를 하지 않고 엠파일은 헤더파일에 있는 것들을 임포트 해 온다…엠파일은 헤더파일에 있는 것들을 다 구현해야 한다…    
* nil은 말그대로 ‘아무것도 없는 값’

## 헤더파일과 엠파일의 메소드 서술    
#### 헤더파일     
		- (id) physicalAttack;    
		- (id) magicalAttack;     

#### 메소드파일     
		-(id)physicalAttack     
		{     
		NSLog(@"마법사의 물리 공격력은 40 이다");     
		return nil;     
		}    

		-(id)magicalAttack;    
		{     
		NSLog(@"마법사의 마법 공격력은 150 이다");     
		return nil;    
		}

## 메소드 호출    
* 호출 코드     
`[객체 메소드];`    
`[you lunch];`    
`[you myName];`         
* 메소드의 호출은 main.m 에서 작성함

## 퀵헬프     
* 엑스코드의 퀵헬프 보기 : 옵션 + 클릭 (혹은 Quick Help Inspector)    
* 퀵헬프는 메뉴별로 작성 가능한 공식적인 도움말     
* 정의부로 점프하기 : 커맨드 + 클릭    
* 퀵헬프는 마크업 랭귀지로 작성된다…메소드나 인업 위에 쓰면 됨    
* 퀵헬프를 위한 마크업 예시

* 퀵헬프 랭귀지 작성법
Formatting Quick Help

> http://goo.gl/8utduz

* 튜토리얼

> http://goo.gl/idJNx7      
> https://goo.gl/ENEuFd    
> https://goo.gl/N93iuO
