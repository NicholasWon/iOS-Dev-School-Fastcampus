## 20170208

### 자료구조
* 자료구조는 메모리 안에서 처리되어야 할, 데이터 안에서 표현되어야 할 방식을 정리
* 원시구조 : 정수, 실수, 문자...하드 어딘가에 3,3.0,a 이러한 것들이 하나씩 그냥 동떨어져 있는 것
* 선형구조 : 배열, 연결리스트, 스텍, 큐, 덱
* 비선형구조 : 트리, 그래프


#### 스택
* 지역변수와 매개변수를 저장
* 메소드가 종료되면 삭제됨
* 가변적으로 계속 만들어지고 사라지는 것들이 들어감…Ex. 클래스 안에서만 생성되어 사용되는 프로퍼티
* Last In First Out
* 자료를 1,2,3 번 식으로 이름을 정해서 넣고 맨 마지막에 들어온 자료부터 빼내는 식

> ex. 뒤로가기 버튼을 누르면 가장 마지막 홈피 이전 페이지 부터 역순으로 뜨는 것

> ex. 설정 <-- 와이파이 <-- 와이파이 고르는 창

* 이들 데이터는 내부적으로 리스트로 연결되어 있을 확률이 높음
* 자료 쌓기는 푸쉬, 자료 꺼내기는 팝으로 명칭

#### 큐 
* First In First Out 
* "큐는 작업대기열, 여럿이 서있는 줄을 의미함"
* 작업대기열에서 가장 많이 사용함

> CPU 스케줄링

* 자료 넣기는 풋, 자료 꺼내기는 겟으로 명칭

#### 덱
* 스택과 큐의 합. 스택과 큐를 활용하기에 애매한 경우에 스택과 큐를 합침
* 순차적으로 쌓인 자료들 앞에서도, 뒤에서도 데이터를 빼오는 것이 가능
* 단 쌓인 자료의 중간을 빼오기는 불가능
* Double Ended Queue 라고도 명칭함

#### 힙
* 동적 할당을 위한 영역(객체)
* heap의 사이즈는 매우 유동적이며, 해당 공간에 들어가는 데이터들도 매우 유동적임…해당 공간에 들어가는 데이터의 예시가 바로 객체임    

#### 데이터
* 전역변수와 정적변수(Static이라는 코드 사용하여 지정)를 저장
* 프로그램이 종료될 때까지 저장됨

#### 코드 
* 프로그램의 코드 저장
* 메소드 코드가 코드영역제 저장되는 예시임
* 프로그램이 종료될 때까지 저장   

> 메모리 영역의 예시

		NSInteger a = 4;
		NSInteger b;     
		//이들 코드는 어떻게 들어갈까?     

> * a = 4 , b 는 스택으로.   
NSInteger는 코드로 들어감

## 비선형구조 

### 트리  
**리스트의 변화**
깃의 브렌치와 유사   
**마인드맵, 가계도, 조직도와 같은 형태의 리스트**.   
**데이터간의 상하구조 관계가 있다. 즉 종속관계를 표현한다**.    

**가계도처럼 부모와 자식 관계를 형성함**.   
   
**비선형구조로 하나의 결과만이 있는게 아님**

>> ex
>> 폴더 디렉토리, 탐색기, 맥 파인더 등 에서 사용
>> Ex. ㄱㄴㄷ 순으로 1차로 자료 분류, ㅏㅑㅓㅕ 순으로 2차로 자료 분류 —-> 갸오오 라는 자료를 찾을 때 매우 신속하게 찾기 가능…만일 일렬로 자료를 연결했다면 맨 처음 데이터부터 하나 하나 찾아야 할 것 —-> 
>> **“검색기능에서 강점”**
  

**메모리에 올려서 자료를 효율적으로 빠르게 찾고 관리해야 하는 경우에 사용**   
  
>> 자식 노드 즉 시블링 노드 끼리는 연결되지 않음…
>> 
>> 시블링 노드 차일드 노드 루트 노드는 각각 브랜치로 연결됨 
>>  
>> 부자 관계 : 루트 노드>차일드 노드>시블링 노드.   

* 트리순회

트리 구조에서 각 노드를 체계적인 방법으로 한 번만 방문하는 과정. 노드를 방문하는 순서에 따라 분류됨

##### 전위순회

1. 진행순서 : 노드를 방문한다
2. 왼쪽 서브 트리를 전위 순회함
3. 오른쪽 서브 트리를 전위 순회함

> 전위 순회는 깊이 우선 순회라고도 부름

##### 중위순회

1. 진행순서 : 왼쪽 서브 트리를 중위함순회함
2. 노드를 방문함
3. 오른쪽 서브 트리를 중위 순회함

> 중위 순회는 대칭순회라고도 함

##### 후위순회
1. 진행순서 : 왼쪽 서브 트리를 후위 순회함
2. 오른쪽 서브 트리를 후위 순회함
3. 노드를 방문함

### 그래프  

1. 최상위 루트가 보이지 않음..."상하관계가 없음...루트 노드가 따로 정해져 있지 않음
2. 페이스북 그래프와 유사…”여섯다리만 건너면 나도 연예인과 안다”
3. 서로간의 관계를 묘사해야 할 때 사용..."연결관계, 데이터들의 관계"  


> Ex. 빅데이터…새로나온 개념도 아니고 예전부터 다들 쓰여온 것… 

##### 트리와 그래프  
트리는 상하관계가 있고, 그래프는 상하관계가 없다…트리는 관계에 대한 설명에 더 가까운  
그래프는 각 데이터가 마구 몇가지나 뻗어나갔는지가 중요한 개념은 아니다…그래서 가지가 여러개라고 해서 그것이 “중추 데이터”라고 보는 것은 아님…그래프상에서 어떤 데이터가 중요한 데이터인지는 사용자가 판단해야 할 문제…  


> Ex. 그래프에서 왕따 데이터를 찾느냐, 여왕벌같은 데이터를 찾느냐는 결국 사용자가 판단하는 문제…   


## 포인터 
### 레퍼런스 변수 
* 메모리의 주소를 가리키는 변수임
* 포인터 자체는 그냥 숫자 변수일 뿐이다. 하지만 그 숫자가 메모리 주소를 가리킨다는 점이 다른 숫자 변수와 다를 뿐이다. 메모리 주소는 정수이므로 정수형을 사용하고 있으며, 32비트 아키텍처 상에서는 32비트 정수, 64비트 아키텍처 상에선 64비트 정수를 사용한다.

>에스터리스크? 
> 

> * 에스터리스크 (*)는 주소값을 가지는 변수를 나타낸다

#### 포인터의 장점
* 메모리에 있는 정보를 쉽게 다룰 수 있다(정보의 수정, 매개변수와 같은)
* 데이터에 대한 접근 속도가 빠르다

#### 포인터의 단점
* 의도치 않은 원본의 수정을 초래할 수 있다
* 포인터가 nil값일때

## 밸류와 레퍼런스 
#### 밸류 
* 실질적인 값을 저장한다
* 구조체 : 서로 다른 타입의 데이터가 묶여 있는 데이터 구조

> 구조체의 예시
> 		
> 		typedef 데이터타입(구조체 키워드 + 태그)
> 		{
>		 <데이터>
> 		}
> 		지정할 이름;
> 
> 		사용할 때는 <지정한 이름>.<변수명>;

#### 레퍼런스 
* 참조하고 있는 주소값 저장

## 배열 
* 인덱스와 번호에 대응하는 데이터들로 이루어진 자료구조임
* 같은 종류의 데이터 타입들을 순차적으로 저장
* 정적 생성
* 인덱스를 통해 데이터에 접근해야 함

>배열은 데이터를 일렬로 순서대로 놓은 것...처음에 신발장을 30명 분으로 만들어 놓으면 해당 크기를 늘이거나 줄일 수 없음. 
>
> 즉 이미 메모리에 30명분을 할당받은 상태이므로 더 받거나 덜 받는 것이 불가함 
> 크기와 칸 갯수가 정해져 있으므로 컴퓨터는 각 위치의 데이터를 빠르게 파악 가능. 즉 메모리 주소를 빠르게 파악 가능함
> 
> 각 칸 별 데이터를 바꿀 수는 있으나 해당 칸을 다른 프로그램이 쓸 수 있게 할당하는 것은 불가함

### NSArray 
* 링크드 리스트 방식으로 만들어진 배열

`ObjectAtIndex`

> 링크드 리스트

> 링크드 리스트(연결리스트)는 배열이 가진 문제점 개선하고자 등장함. 신발장을 통짜가 아닌 한개씩 조립식으로 만든 것
> 
> 링크드 리스트는 각 노드(구조체)가 데이터와 포인터를 갖고 있음. 다양한 데이터 구조를 사용할 수 있음. 노드의 위치는 메모리 어디든지 가능함. 다음 노드로 이동할 때는 노드가 가지고 있는 포인터를 이용해야 함
> 
> * 단일 연결 리스트 


> **"하나의 노드 당 하나의 포인터(다음 노드의 주소)를 가지고 있다"**
> 
> **""하나의 노드의 포인터가 잘못되면 나머지 노드에 영향을 미친다"**
> 
> **"선행노드(이전 노드)를 찾는 것이 어렵다"**
> 
> **"노드 탐색시 헤드 포인터(처음)부터 시작해야 한다"**

> * 이중 연결 리스트

> **"노드가 양방향의 링크를 가지고 있으므로 탐색이 다른 리스트보다 용이함"**

> **"다른 리스트에 비해 코드가 복잡하고 메모리 공간을 많이 차지한다"**

> * 원형 연결 리스트

> 단순 연결 리스트와 유사하나 맨 뒤 데이터가 맨 앞 데이터에 대한 꼬리표를 갖고 있는 것
> 
> 
> 자료들의 순서 없이, 순환하면서 뭔가를 찾아야 할 때 사용하는 방식
> 

> "노드 포인터의 연결이 원형을 이룬다"

> "헤드(처음)을 마음대로 변경할 수 있다"
> 
> "단순 연결 리스트에서 마지막 원소가 처음 원소를 가리키게 하면 원형 연결리스트가 됨".
> 
> 
> "이중 연결 리스트의 처음과 끝을 이으면 이중 원형 연결 리스트를 만들 수 있음" "스트림 버퍼에 많이 사용".
> 
> 
> "이미 할당된 메모리 공간을 삭제하고 재할당하는 부담이 없어서 큐를 구현 할 때도 적합"
> 
> "성능 면에서는 배열과 비교해서 안좋지만, 삽입과 삭제 위해서는 더 나은 방법임"
> 
> "요즘은 컴퓨터 성능이 좋아져서 배열을 쓰지 않음. 하지만 게임, 한정된 하드웨어 자원을 써야 하는 곳에선 배열을 여전히 사용중"
> 
> "오브젝티브 씨에서 말하는 어레이는 '배열'을 의미함"

### 청크 리스트 
* 배열의 장점 + 리스트의 장점
* 리스트의 맴버가 배열임
* 청크 리스트의 발전형 == B+Tree

### NSMutableArray 
* NSArray를 상속받은 배열. 여러 종류의 데이터 타입들을 저장 가능
* 동적 생성이 가능함
* 수정이 용이함

## 딕셔너리 
* 어레이는 인덱스를 통해 데이터를 정렬함.   
* 딕셔너리는 인덱스가 아닌, **키값**을 통해 데이터에 접근하고 가져오는 방법임.
* 키값은 일반적으로 String 자료형으로 사용


`ObjectForKey`

* 해시테이블을 사용한 데이터 구조임…해시테이블의 특징 상 **데이터의 순서가 보장되지 않음**
* NSDictionary : 정적 데이터를 저장함
* NSMutableDictionary : 동적 데이터를 저장함