## 20170113

## 소프트웨어 공학

· 공학?    
·· 수학과 자연과학 기초로 해서 가끔 인문 사회과학 지식을 이용해 공동의 안전과 건설 복지를 위해서 유용한 사물이나 환경을 구축하는 것을 목적으로 하는 학문    
·· 공학의 영역은 넓고 여러가지 분야로 세분화 되어 있음    
·· 공학은 유용한 사물이나 환경을 구축하는 것을 목적으로 하는 학문    
·· 컴공은 컴퓨터이론을 바탕으로 사람이 필요한 것을 만들거나 도움을 주는 학문

· 소프트웨어공학?    
·· 소프트웨어 개발 운용 유지보수 및 폐기에 대한 체계적인 접근법    
·· 결과적으로 말해서 소프트웨어를 잘 만들기 위해 인문학적 사회적 지식을 동원해 소프트웨어를 잘 만들 수 있도록 연구하는 학문

· 소프트웨어공학    
요구공학    
아키텍처  
개발방법론  
테스팅  
프로세스  
형상관리  
프로젝트관리

· 소프트웨어개발 생명주기 모델  
·· Software Development Life Cycle Model  
·· 소프트웨어를 어떻게 개발할 것인가에 대한 흐름  
·· 주먹구구식, 폭포수, 프로토타이핑, 나선형  
·· 소프트웨어가 탄생하기 까지의 긴 흐름을 도식화…   
··· 소프트웨어 개발 방법론은 흐름에서 발생하는 반복적 작업들을 어떻게 처리할 지를 정리한 것

··· 주먹구구식   
—말 그대로 되는대로

··· 폭포수   
—리콰이어먼트(요구사항분석)  
—디자인(이 소프트웨어가 어떻게 구성되고 설계되야 하는가…즉 구조설계 단계…”소프트웨어 아키텍처 설계”…팀장과 부장이 주로 담당…하단 프로그래머는 팀장의 설계 대로 콘크리트, 벽지를 바르는 셈)  
—임플리멘테이션(“공사 하는 단계”)  
—베리피케이션(“검증단계”…사용자의 요구사항에 맞게 제대로 소프트웨어를 구현했는지 확인)  
—메인터넌스(“유지보수 단계)

---- 프로그램을 만드는건 책을 쓰는 것과 유사…A상황에선 이렇게 동작하고 B 상황에선 저렇게 동작해야 한다는걸 일일이 다 쓰는 것...  
대주제 구성(동물의 종류)—>목차 구성(갑각류, 포유류, 양서류 등)…”디자인 단계와 유사”—-> 각 목차별 콘텐츠 채우기  
——->주제에 맞지 않아서 큰 주제와 작은 주제를 바꿔가며 목차를 바꿀 수도…  
---- 프로그램을 만들려면 얼마나 걸릴까? 특정 기능을 구현하려면 얼마나 걸릴까?

········ 폭포수 방식의 문제  
-- 앞 단계를 진행해야 다음단계 진행 가능  
— 요구사항 분석부터 틀려버리면 망함…  
Ex. 클라이언트 : 누가 벽돌집으로 해달래 모던한 집으로 해달라 그랬지…라고 하면 답 안나옴)…뒷단계에서 진행한 걸 다 갈아엎어야…  
-- 앞 단계가 수행되지 않으면 뒷 단계를 진행 불가함…  
Ex. 디자인단계에서 팀장이 수정을 해야 하나 말아야 하나 고민하기 시작하면 다른 사람들은 기다려야 됨…  
-- 전체 과정이 끝날 때 까지 시간이 몇개월, 반년, 몇년이 될 수도 있음…  
---- 핵심은 한 번 틀어지면 시간소모가 극심해진다는 것

··· 프로토타이핑   
···· “시험삼아서 만들어 보는 버전  
——요구분석  
---- 프로토타입설계  
---- 프로토타입개발  
---- 프로토타입평가  
---- 구현  
---- 인수 및 설치  
“프로토타입 평가에서 반려시키고 요구분석 단계로 다시 가기도 함”

···· 프로토타이핑모델이 문제점  
“프로토타이핑은 예제를 보여주는 모델하우스를 지어서 우선 보여주는 방식…  
---- 막상 클라이언트들은 모델하우스를 보면 그대로 옮기고 싶어하지, 그 모양 그대로 시공을 하고 싶어하진 않음…  
———>부실공사의 위험이 커진다…프로토타입 평가를 거치고 또 다음 프로토타입을 만들어서 평가를 하겠다고 함…그러다 기간이 뒤로 마구 밀려서 “모양 대충 잘 나왔으니 A형 프로토타입으로 가자”고 결정—> 결과적으로 집이 아니라 모델하우스 같은 소프트웨어가 나오는 격  
---- 프로토타입 제작과 실제 구현을 위한 중복이 생길 수 있다…  
---- 요구분석 후 프로토타입 제작시 클라이언트 입맛대로 바꾸기 시작하면 일정이 미뤄짐  
---- 개발진과 클라이언트 간 의사소통 및 피드백, 컨펌 때문에 일정이 미뤄짐

··· 나선형 
·· · 프로토타입 문제점을 보완해보자는 취지
·· ·· 스텝바이스텝으로 진행해보자

---- 고객과의 의사소통  
---- 계획 및 정의  
---- 위험분석  
Ex. 방 만들기가 실패 했을 때 차선책 대안은 있나?  
---- 구축…프로토타입이 아닌 실제로 만듦  
---- 고객평가…평가 후 OK면 끝, 아니면 다시 허물고 만듦

·· ·· 나선형의 단점  
---- 전체 진행 시간이 매우 늘어남  
---- 커뮤니케이션 비용(소통 시간 등)이 늘어남…고객이 딜레이 되면 다음 단계들도 딜레이…  
“양질의 소프트웨어를 만들 수 있으나 시간과 비용이 더 많이 듬”  
---- 뭔가 이상한 모양으로 완성이 될 수도 있음  
Ex. 북유럽풍 목재 안방, 화장실을 만들다가 갑자기 한국식 현관을 지어달라고 요구하고
2층은 공중정원으로 만들어 달라고 하다가 갑자기 없애고, 또 2층에 미국식 주방을 만들고, 지붕은 원래 계획대로 한국식 기와를 얹음…  
“전체적으로 이상한 집이 완성 됨”

··· ··· “상기 모든 방법론들은 적절히 섞어서, 상황에 맞춰서 뭘 적용해야 할지, 절대적인 진리는 아니니 어떤 방식으로 개발진행을 할 지는 생각을 해봐야 함”  
··· ··· 소프트웨어가 사용자위주인지, 기업위주인지, 회사 분위기는 어떤지에 따라 개발 방법론은 많이 달라진다

## 소프트웨어 개발 방법론  
· 소프트웨어 생산하는데 필요한 반복적 과정들을 정리한 것  
· 구조적 프로그래밍, 객체지향, 고속 개발 방법론, 익스트림 프로그래밍(Agile), 스크럼(Agile), UP…그 외  
· 소프트웨어 개발 방법론은 흐름에서 발생하는 반복적 작업들을 어떻게 처리할 지를 정리한 것  
·· 소프트웨어 개발 생명주기 모델은 소프트웨어가 탄생하기 까지의 긴 흐름을 도식화…  
··· “우리 스타트업은 평등한 문화와 함께 에자일하게 개발해요?”  
“그래서 어떤 프로세스로 개발해요?” 라고 물으면 에자일하게 개발해요 라고 답한 쪽에서 자세한 답을 못할 확률이 높음…자세하게 말을 못하면 그냥 용어 하나 듣고 폼만 잡는 인간일 확률이 높음    
“우리는 스크럼과 유피 익스트림 프로그래밍과 같은 방법을 융합해서 개발하고 있습니다” 라고 자세히 답해주는 담당자가 매우 자세히 알고 있는 것

▲ 에자일 개발 프로세스  
고전적 방법론과 구별되는 가장 큰 차이점은 Less Document oriented(기획문서와 같은…요구사항을 다 정리하고 분석하고 문서를 전달하는 방식이 아닌…또한 실제로 문서로 산출해내도, 또한 문서를 산출해냈더라도 문서대로 일이 흘러가지 않음…)  
즉 문서를 통한 개발법이 아닌 Code Oriented(그날그날 만나서 코드에 대해 논해보고 직접 만들어보는)  
즉 실질적인 코딩으로 개발하는 것, 문서의 작성을 최소화 해보자는 것  
스타트업은 물론, 지금 경제상황에서 모든 기업은 하루하루 살아남는게 문제…때문에 빨리빨리 일을 진행하는데 집중…때문에 기술적 부채에 시달리거나 위험수위에 도달한 기업들도 많다…  
Ex. 2011년 기준으로 모 배달기업(배달의민족 우아한 사람들)에서 시스템 구축 시 20년전 기술로 구축함…윈도우서버에 ASP를 담는 식으로…앱 만들때도 외주를 주는 식으로…지금 프로그래머들에겐 엄청난 빚으로 돌아와서 지금 프로그래머들은 독박씀  
왜? CTO가 (김봉진 이사)20년전 기술만 알아서… “적절한 기술적 부채는 이로울 수 있다” 는 식으로…말 도 안됨…  
결국 짜장면데이, 무슨 데이, 축구 시즌 때마다 서버가 마구 터져나가서 프로그래머들이 서버의 데이터들을 통째로 갈아버리고 있음…이럴 때 유지보수 시간 및 비용은 기하급수적으로 늘어남  
앞을 예측해 개발하지 않고 일정 주기를 가지지 않고 끊임없이 프로토타입을 만들어내며 그때그때 필요한 요구를 더하고 수정하여 하나의 커다란 소프트웨어를 개발해 나가는 어댑티브 시스템  
개발자는 문서 정리할 시간도 없고 요구사항 발생하면 빨리빨리 소프트웨어적 형태를 구현해내야 함…  
결론적으로, 개발자는 “완벽한” 집을 만들 수 없다는 결론에 도달해서 에자일 개발 프로세스를 생각해본 것……세계적인 건축가들이 기능적으로 완벽한 뉴욕같은 신도시를 설계해도 그 안에는 비인간성, 기계적 구조, 삭막함 같은 단점이 생겨나는 것과 유사한 건가?


에자일 자체는 하나의 개발 방법론이 아니다…  
에자일은 에자일한 개발을 가능하게 해주는 다양한 방법론 전체를 가리키는 말  
즉 에자일은 “빠르고 효율적으로 잘 개발하게 해주는 모든 수단을 총동원하고 방법론을 생각해보는 발상을 기본 전제로 가지고 있는 것 뿐” “개발은 하나의 방법론을 쓰는게 아닌 적절히 조직에 융합시키고, 다른 방법론도 섞어내고 고안해내는 작업이므로”

## UML   
· 통합 모델링 언어…Unified Modeling Language  
· 표준화된 범용 모델링 언어  
· 특히 자바에서 굉장한 힘을 발휘한다  
· 객체지향 소프트웨어 집약 시스템을 개발 시 산출물울 명세화 시각화 문서화할 때 사용…  
· 이 언어로 산출물을 작성 정리하면 어느 시스템 어느 회사에서 든지 읽고 쓰고 확인 가능…  
· 그러나 이것을 실질적으로 제대로 회사에서 쓰는 경우는 많지 않음…  
· 메소드, 객체지향 등 각종 설계를 문서화 가능…  
· 소프트웨어 개발 방법론+모델+클래스 다이어그램  
——메소드는 무엇이 있고 변수는 무엇이 있으며, 언제 끝날 수 있는지 등을 서술 가능  
——단순히 다이어그램만 그리는 것이 아닌…다이어그램을 표준에 맞게 잘 그려 놓으면 우리에게 코드까지 다 만들어 준다  
Ex. 집을 설계할 때 방은 몇개, 보일러는 어디에, 벽지는 무엇을 어느 벽에 쓴다고 다이어그램화 하면…컴퓨터가 알아서 철근 박아주고, 벽지 발라주고, 보일러 넣어줌…사용자는 가구만 사와서 넣어놓는 식으로 쓸 수 있음…  
——UML을 안쓰는 이유? 몰라서 혹은 귀찮아서

## TDD  
· 테스트 주도 개발  
· Test driven development   
· 매우 짧은 개발 사이틀을 반복하는 소프트웨어 개발 프로세스  
· 하나의 프로토타입, 혹은 나선형모델에서 하나의 방을 만들든…테스트를 코드로 수행할 수 있도록 구성, 진행 하는 것…테스트 끝나고 다음개발 진행하고의 반복…코드품질을 반복하며 계속해서 개발하는 것…  
··  결함을 점검하는 자동화된 테스트케이스 작성—레드 단계  
··  케이스 통과위한 최소한의 양의 코드를 생성—그린 단계  
··  새 코드를 표준에 맞도록 리팩토링—리펙터 단계

——빨리빨리만 개발하면 퀄리티가 낮아지니…퀄리티 보장하고 코드가 제대로 작동하는지 체크하고자 코드를 따로 짜는 방식  
Ex. 음악앱을 만들 시 각 버튼을 누르면 이전곡 재생 다음곡 으로 되게 코드를 짜야 함…  
코드가 제대로 작동하는지, 안되는지 체크하는 코드를 소량 따로 작성한다…이 소량코드가 제대로 작동하는지를 개발자가 확인하는 것…컴퓨터가 코드가 제대로 동작하는지를 확인하는 것…  
“다음곡 버튼을 눌렀을때 재생 버튼을 눌렀을때 동작을 제대로 하는지 체크해 봐야 한다” 라는 소량코드를 작성하는 것  
버튼에 관련된 코드는 우선 러프하게 작동만 하게 짜고 테스트를 할 수 있음…잘 되었으면 좀더 간결하게 할 수 있음…(리펙터 단계)  
코드의 간결화는 나 뿐만 아니라 같이 일하는 다른 사람, 후에 들어오는 사람, 내가 나가고 들어오는 사람들도 코드를 보고 수정해야 하므로 중요함


· 에자일과 쌍으로 자주 나오는 용어…“우리회사는 에자일로 TDD하게 개발해요”  
—-왜?TDD는 중요한 일이지만 실제로 하기 매우 어렵다…버튼 코드 만들고 테스트용 소량코드를 만들기는 매우 힘듬…소량코드에서도 버그가 나올 수도 있으니…일정압박에 시달리게 되므로 초반엔 테스트코드를 잘 작성하나, 뒤로 가면 갈수록 투자시간을 줄이게 됨…하지만 매우 좋은 습관이니 개발자는 항상 테스트코드를 만들 수 있도록 자기 스케쥴을 짜야 한다  
테스트코드 작성은 기술적부채를 탕감하기 위한 방법 중 하나  
처음과 중간에 탄탄하게 작성해 두면 후에 버그 발생률이 매우 많이 줄어들 게 됨  
실습에서 해볼 시간이 없으면 블로그 든 구글이든 찾아서라도 해야 함

· 테스트케이스의 작성  
테스트케이스는 매우 극적인, 드문 상황까지 고려하지는 않음…

## PDD  
· 계획기반개발(Plan driven development)  
· 계획 세우고 그 계획 실천하는데에 많은 시간과 노력을 할애하는 개발법…문서 하나에 매우 자세히 서술하고 이를 기반으로 코드 구현

## 형상관리  
· 소프트웨어개발 및 유지보수 과정에서 발생하는 소스코드, 문서 , 인터페이스 등 각종 결과물에 대해 형상을 만들고 이들 형상에 대한 변경을 체계적으로 관리 제어하기 위한 활동  
---- 깃을 통해 소스코드 뿐만 아니라 이미지, 도큐먼트, PPT등의 버전관리를 수행 가능  
---- 개발자는 소스코드 위주로 개발을 하게 되며, 디자이너도 같은 레포지토리를 활용하면서 이미지를 업데이트 할 수도 있다

· 버전관리  
·· 형상관리의 일부  
·· 일반적인 소프트웨어 소스코드만의 형상을 관리하는 것…  
·· SVN, 깃, Merqurial, CVS 등의 서비스 존재  
·· 히스토리 남기기, 관리에 기여…  
··· 삽질한 사람을 숙청하기 위해서 가장 필요함…”A가 B코드를 작성해서 C버전에서 D에러가 생겼으니, A를 숙청하고 C 버전을 고치거나 다른 버전을 쓰자”는 결론을 내기 위해서  
··· 따라서 커밋 메시지를 매우 자세히 써야 함…”해당 코드는 A가 시켜서 B라고 작성했고, C라는 기능을 구현하고자 D시간으 들여서 작성했다”…메일 역시 커뮤니케이션 히스토리 관리를 위해 필요한 것과 유사…

· 프로젝트관리  
문서 일정 예산 인력 고객 위험 품질 등 의 관리…팀장급 및 부장급이 프로젝트 관리를 위해 신경써야 하는 모든것에 대한 관리

## 프로그래밍 언어  
C 자바 파이썬 코볼 루비 등…  
“우리 환경에 적합한 단어, 언어를 만들어 보자 해서 프로그래밍 언어도 필요에 의해, 컴퓨터 환경에 의해, 개발목적에 의해 여러개가 나온 것”  
각 언어의 점유율의 순위는 거의 매일 주기로 바뀜   
스택오버플로우에 들어가 볼 것…가장 핫한 기술 및 임금까지…  
전 세계적으로 아이오에스쪽 일자리가 60 안드로이드가 40의 비율…미국은 60 40 독일은 반 반…인도도 반 반…일본은 70 30…호주도 60 40

· 언어의 발전  
—-그림으로 보는 것이 더 나음…

### 1954년이전   
천공카드 어셈블리어, 0과1만 으로 프로그래밍…

### 1954년 11월…”고급언어의 등장”    
포트란…인간이 알아볼 수 있는 글자로 프로그래밍이 가능한 시작   
입맛에 따라 문법이 분화되기 시작함

### 1964년   
베이직 등장

### 1969년   
B언어 등장    
전화회사인 Bell 연구소에서 시작

### 1975년    
C언어 등장…B언어 다음에 나온 제품이라서…  
MS 베이직 등장  
포트란은 계속 계보 이어감…

### 1979년  
C(K&R)   
C언어의 개정판…  
이후 C언어에서 여러 줄기가 나오기 시작

### 1980년


### 1983년
오브젝티브C의 등장

“자바와 자바스크립트는 매우 완전히 다르다…서로 독자노선을 탄다”

“각 언어들은 시대에 맞게 편의기능 등을 추가하면서 개정되고 있다…매우 많이 자주”

“언어들은 강점, 특징, 문법 등이 다양하다 따라서 뜨는 언어 지는 언어도 달라진다…예를 들어 최근엔 병렬처리가 강조되어 스위프트 하스켈과 같은 함수가 1급 개체인 언어들에 사람들이 관심을 많이 갖게 됨…개발자들이 필요 목적에 의해서 적합한 언어를 계속 찾는 셈”

“파이선이 부각되는 것은 배우기 쉽고 문법이 간결해서 교육용 언어로 밀어주는 경우…성능도 어느정도 되어서”—사실 프로그램을 제대로 작성하기 시작하면 쉬운 언어는 없다…개발자의 지능과 잔머리의 문제지…

“C언어를 배우면 다른걸 배우기 쉽다고 하는 이유…현재 존재하는 대부분의 언어들이 C언어에 기반한 게 많음…C언어를 배웠다고 다른언어를 매우 쉽게 배우는 식은 아님…스페인어 마스터가 영어, 독일어, 이탈리아어를 한국인보다 빠르게 배우는 수준”

“C언어만큼 간결하고 명령어도 몇개 안되고 문법도 복잡하지 않고 컴퓨터 내부 구조를 까볼 수 있는 언어는 없다…근데 컴공에서는 어렵다고 한다…왜?”
---- >제일 처음 배운 언어라서 더럽게 어려운 것…이를 완화하는 것이 컴퓨터,메모리,운영체제와 프로그램의 소통 및 구동, 전산에 대한 지식임…
Ex. 포인터라는 개념을 이해하려면 컴퓨터의 구동방식에 대해 상당 수준 숙지해야 함

“자바가 좋아요 C가 좋아요?”—-각자 지지지들끼리 싸우면 답 안나옴…그냥 언어는 장단점이 있음
—-인터넷에서 대충 찾아보고 어느정도 각 언어들의 장단점이 대충 있다고 알아봐야…

프로그래밍 언어의 종류
· 고급언어에서 저급언어(기계어…컴터가 알아들을 수 있는 0101010101)로 변환되는 과정에 대한 분류
(어셈블리어는 기계어 다음에 나온거…)
· 코드를 01010101로 번역해주는 코드도 따로 있다…
· 핵심은 고급언어를 저급언어로 바꿔줘야 한다는 것…

1.컴파일 언어…C, C++, Go    
·· 번역되는 시점은 파일을 실행할 때 Ex. EXE파일 실행…  
---- 업데이트는 EXE파일이 교체되는 것…0101010101이 파일의 형태로 들어와 있는게 실행파일  
---- 버그수정을 위해 코드 고치고 사용자들에게 배포할 때…코드를 배포할 수 없으니 코드가 0101010101로 변환된 “실행파일”이 사용자의 컴퓨터로 가는 것…코드를 01010101로 변환해주는 언어가 컴파일 언어  
·· 즉 사람이 쓰는 고급언어를 기계가 쓰는 저급언어로 번역하는 과정이 필요한 것…  
·· 고급언어를 저급언어로 ‘이미’번역을 끝내고 사용자에게 파일 형태로 배포해 주는 것  
·· 실행속도가 빠르다  
·· 한번 배포하면 그 다음에 수정을 하기가 어렵다, 한 번 만들려고 할 때 복잡하다  
·· 게임은 99프로가 컴파일 언어…초당 교환되는 정보 양이 막대하므로 실시간으로 번역이 되는 인터프리터언어는 비효율적일것  
·· 한 줄의 코드의 버그를 고치기 위해 다시 몇십만줄을 번역을 해서 실행파일을 다시 만들어야 함…번역시간이 더 오래 걸리는 결과 초래  ——->수정과 배포에 있어서 다소 불리함  
·· 컴파일언어는 운영체제 종류에 따라 만들어야 함…윈도우버전, 맥버전 식…즉 목적과 아키텍처, 시스템환경에 맞게 만들어야 함…각 운영체제 마다 01010101을 알아듣는 방식이 다를 거므로…원서를 독일어,불어,스페인어로 각각 만들어야 하듯…

2.인터프리터 언어…베이직, 자바스크립트,파이선, 루비  
고급언어를 실시간으로 0101010101로 번역해서 실행까지 해주는것  
01010101로 실행파일을 배포하는 것이 아님…  
다음 명령어를 사용자가 내리면 컴퓨터가 또 번역을 하고 실행을 하는 것  
·· 유지보수와 수정이 더 낫다…인터프리터 언어는 한줄을 바꿔서 다시 저장만 하면 어차피 실행할 때마다 번역을 하므로 시스템을 껐다 킬 필요도 없다  
·· 구동속도가 느리다—컴파일언어와의 속도의 차이는 크며, 속도는 하드웨어의 차이에 따라 달라진다


3.바이트코드 언어…자바, C#  
·· 컴파일언어와 인터프리터의 장점을 합쳐보자는 발상…  
·· 컴파일언어는 운영체제 종류에 따라 만들어야 함…윈도우버전, 맥버전 식…즉 목적과 아키텍처, 시스템환경에 맞게 만들어야 함…각 운영체제 마다 01010101을 알아듣는 방식이 다를 거므로…원서를 독일어,불어,스페인어로 각각 만들어야 하듯…  
··· 모든 언어를 다 구사하는 만능통역사와 같은 기능은 없나?  
——>고급언어로 만든 것을, 중간의 또 다른 통역사가 맥,윈도우,ios,안드로이드 등 다양한 시스템이 알아들을 수 있는 언어로 번역하게끔 시스템을 구성…즉 “통역사”가 알아들을 수 있는 언어로 짜면 통역사가 알아서 다 번역을 해주는… 고급언어와 통역사 간의 번역은 배포할 때, 각 맥 윈도우 ios등 을 위한 번역은 배포하고, 사용자가 실행하는 단계

“개발자는 고급언어 자바로 JVM(“가상머신”)이 이해할 수 있는 언어로 통역—JVM이 배포된 파일 실행 시 각 시스템에 맞게 통역…”  
“JVM이 각 컴퓨터에 설치되는 이유”  
·· 가상머신만 있으면 어떤 시스템에도 맞는 범용적 파일을 만들 수 있음…  
·· 가상머신이 필수적…맥용 윈도용으로 다양하게 있음  
·· 가상머신은 그 자체가 또다른 프로그램…사용자 프로그램을 구동하려면 자바가 가상머신에게 실시간으로 번역과 같은 여러 명령을 내려야 됨…즉 구동을 위해 또 다른 프로세스가 구동되어 시스템 리소스를 잡아먹게 됨  
·· 특정 환경에 최적화 하기가 어려움  
·· 인터프리터 언어와 많이 가까운 방식  
··· “자바는 범용성을 위해 많은 것을 포기…인터프리터 언어처럼 리소스를 많이 먹고, 컴파일 언어가 수정 및 배포가 어려운 것 처럼 수정 및 배포 위해서 가상머신이 알아들을 수 있는 언어로 수정한 것을 컴파일 해줘야 함”


Ex. 책을 직구해서 원판을 읽으면 독서 속도가 느릴 것…따라서 컴파일 언어와 인터프리터 언어는 미리 해석이 되어 있는지 의 차이

··· 서버와 컴파일언어, 인터프리터언어  
Ex. 날씨를 알려주는 프로그램  
사용자들이 접속 시 날씨에 맞는 정보를 사용자에게 돌려주는 프로그램을 작성 시…  
강남구 날씨를 알려주는 대신 강동구 날씨를 알려주는 버그가 발생하면…  
컴파일언어는 다시 수정하고 번역하고, 패치하는 과정이 복잡하다…  
그러나 인터프리터 언어는 한줄을 바꿔서 다시 저장만 하면 어차피 실행할 때마다 번역을 하므로 시스템을 껐다 킬 필요도 없다…즉 인터프리터언어는 수정과 유지보수에 있어서 더 낫다…

프로그래밍 패러다임에 따른 언어 분류  
“프로그래밍의 관점”

· 객체지향 프로그래밍 패러다임  
·· 프로그램을 상호작용하는 객체들의 집합으로 표현  
·· 한때 굉장한 각광  
·· 기본적으로 먼저 배우는 내용들  
Objective c python swift c++ C# smalltalk perl ruby, java

· 함수형 프로그래밍 패러다임  
·· 프로그램을 상태값을 지니지 않는 함수값을의 연속으로 표현  
·· 현재 굉장한 각광…멀티쓰레딩과 관련  
python swift c++ C# smalltalk perl ruby, java

Ex.   
집을 지을 때 기능적으로 나은 아파트, 예쁜 저택 등  
이층집을 지을 때 복층, 저택, 원룸2개 붙이기 등   
발상이 조금씩 다름  
프로그래밍 하던 사람들이 어떤 방식, 어떤 관점으로 생각하니 프로그래밍이 더 나았는지를 생각해보고 분류 및 나열

· 그 외에도 주체지향, 정책기반, 탈객체, 반사적, 구조적과 비구조적 등 매우 다양함

## 객체지향 프로그래밍 패러다임

· 컴퓨터 프로그램을 명령어의 목록을 보는 시각에서 벗어나 여러개의 독립된 단위 즉 객체들의 모임으로 파악해 객체간의 상호작용으로 프로그램의 동작을 구현하고자 하는 것  

Ex. 예전에 하나의 제품을 만들 때 명령을 1~10까지 그냥 만듬…기계는 불편함을 느끼지 못하고 진행함  
시대가 발전함에 따라 컴퓨터가 사용되는 다양한 목적이 생겨남…사람과 관련된 일들을 처리해야 할 일이 생겨남  
근데 기존같은 목록은 사람과 관련된 일을 처리하기가 어려워짐  
즉 프로그램 동작도 사람이 사는 것 같이 동작되게끔, 프로그램 내부도 사람사는 나라,사회 같이 만들어 보자는 발상  
RTS게임에서 각 유닛들이 서로 치고받고 싸우듯이 메모리 안에서도 각 객체들이 치고받으면서 일처리를 하게끔 해보자는 발상

· 클래스와 객체  
·· 클래스—->실질적인 형태(클래스의 객체화)—->객체  
·· 클래스는 세상에 존재하는 무언가를 설명서 같이 서술해 놓은 것…이 설명서대로 메모리에 무언가가 생겨나면 객체가 됨…  
Ex. 사람에 대한 설명서=사람에 대한 클래스   
사람이 하는 일의 목록: 이름 나이 성별 먹는다 잔다 싸운다………사람이 이런것들을 한다, 특징이 있다는 것을 코드로 짜놓고…즉 클래스를 만들고…컴퓨터는 이 설명서를 보고 메모리에 공간을 할당하고 설명서와 똑같이 짜놓은 코드를 보고 메모리 안에 코드와 똑같은 것을 만듬…이것이 바로 객체…   
컴퓨터가 설명서를 보고 메모리에 복제인간을 만들면 객체가 여러개가 생기게 됨…  
메모리 안에서는 객체들이 인간들이 서로 상호작용 하듯이 상호작용 함  
·· 프로그래머가 하는 일은 클래스에 대한 서술, 객체를 x개 생산하라는 명령, 객체에게 함수대로 작동하라는 명령 3가지임

· 객체  
· · “Object” “의식이나 행동의 대상” = “의식과 행위를 가지는 형체”  
· · 객체는 메모리의 용량이 허용되는 한 생성 가능  
· · 객체의 특징을 얹은 C = 오브젝티브 C…C언어 자체엔 객체라는 개념이 없다  
·· 객체의 속성은 클래스에 서술된 범위 내에서 여러 객체마다 각자 다를 수 있다.

· 클래스  
·· 객체가 가질 수 있는 속성과 행위를 “코드로 작성하여” 정의하는 틀 Ex. 템플릿 설계도  
·· 현업의 프로그래머도 클래스와 객체를 구분하지 못하는 경우가 많다…”그냥 이렇게 하니 되더라”라는 식으로 일함  
·· 코드로는 클래스와 객체의 차이를 쉽게 파악하기 힘들다…머리속으로 계속 상상을 해야…

· 클래스—>객체  
·· 자동차 클래스 : 설계도 —->공장 : 컴퓨터 —>객체의 생산 —->자동차 오브젝트 생성 + 메모리에서 돌아다님…각 자동차 오브젝트 들은 색깔도 다를 거고 사용 연료도 다를 거다…

·· 자동차 클래스   
··· 속성=“변수” : 색상 연료형식  
··· 기능=“함수” : 전진(전진은 기어를 ~~~하고), 후진(후진은 기어를 ~~~하고), 충돌방지(다른 차가 맞은편에서 오면 우측으로 피해라)…함수는 객체가 하는 일을 미리 서술해 놓는 것

---- >”객체의 생산”  
---- -- >자동차 “객체”…클래스에 서술된 변수와 함수에 따라 객체들이 생성됨…객체들에게 전진 후진 명령을 내리면 객체는 전진을 이미 어떻게 하는지 알고 있으므로 알아서 움직인다  
따라서 프로그래머가 하는 일은 클래스에 대한 서술, 객체를 x개 생산하라는 명령, 객체에게 함수대로 작동하라는 명령 3가지임

·· 음악재생기와 클래스—>객체  
··· 음악플레이어 클래스  
변수   
음악파일 용량  
함수  
재생 : 음악파일을 불러와 스피커로 소리 출력한다  
정지:재생 중지하고 스피커로의 소리 방출 중단한다

## 객체의 생산

음악 플레이어  
속성—music.mp3 10함수, 재생, 정지  
속성—sound.wav 15함수, 재생, 정지  
속성—english.mp3 20함수, 재생, 정지

## 프로그래밍 용어

· 개발자?  
·· 프로그램을 만들기 위해 협업하는 사람들…프로그래머, 디자이너, 기획자…디자이너와 기획자도 소프트웨어 개발자가 될 수 있음…”소프트웨어 프로그래머”가 더 적절한 표현  

· 서버와 클라이언트  
·· 서버와 클라이언트는 상대적인 개념  
·· 서버는 데이터를 제공해주는 컴퓨터  
·· 클라이언트는 정보를 전달받는 컴퓨터…  
·· 서버—>데이터제공—>클라이언트  
Ex. 날씨서비스  
사용자—-네이버 기상서버—-구글 기상서버  
---- 사용자가 네이버 기상서버에서 날씨정보를 받아오면 네이버 기상서버가 서버이고 사용자가 클라이언트…그러나 네이버 기상서버는 구글 기상서버에서 날씨정보를 받아오므로 네이버와 구글의 관계에서는 구글이 서버이고 네이버가 클라이언트  


· 백앤드와 프론트앤드  
·· 프로그램=백앤드+프론트앤드 <—-> 사용자  
··· 프론트엔드는 사용자에게 명령을 받고 뒤의 보이지 않는 곳을 명령을 전달하고, 백에서 받은 명령을 사용자에게 보여줌  
“프로그램에서 보이는 부분” “다른 프로그램과의 접점”  

··· 백엔드는 점수계산 조율과 같은 사용자의 눈에 보이지 않는 사항들을 처리함  
“프로그램에서 보이지 않는 부분” “명령을 뒤에서 처리하는 부분” “백앤드를 무조건 서버라고 볼 수 없다”  
·· 서버+백엔드+프론트엔드(API) <—> 클라이언트  

··· 개발자들끼리는…특히 디자이너와 기획자…백앤드 프론트엔드 같은 용어들 때문에 미스커뮤니케이션이 발생한다…  
불안하면 초등학생도 이해할 수 있을 정도로 설명하는 것이 낫다

· 스레드  
·· 작업관리자에서 나오는 용어  
·· 프로세스 내에서 작업이 실행되는 흐름의 단위    
·· 멀티스레드 : 다중스레드   
·· 멀티스레드와 멀티태스크의 차이
멀티스레드는 하나의 프로세스 안에서 여러 작업흐름을 만드는 것
멀티태스크는 한 번에 여러가지 프로세스를 처리하는 것  

Ex. 게임 프로세스와 멀티스레드  
배경음악 재생 작업 스케쥴  
화면에 그래픽 출력하는 작업 스케줄  
성우의 나레이션 작업 스케줄  
점수 계산하는 작업 스케줄  
——상기 작업 스케줄을 제어하는 것이 멀티스레드…중추적인 역할을 하는 것이 메인스레드…  

Ex2 음악을 들으면서 책 읽기와 멀티태스크  
뇌는 0.1초는 책을 읽고, 0.1초는 음악을 들을 수도 있다…멀티태스크의 기본 개념
말하면서 밥먹기…입은 하나인데 밥먹고 말도 해야 함…찰나의 매우 짧은 시간 내엔 동시에 일어날 수 없음  
“실질적으로 멀티태스크는 여러 프로세스를 순식간에 번갈아면서 시행하는 것”  

Ex3 책 읽어주는 프로그램과 멀티스레드   
한 프로그램(프로세스) 내에서 애니메이션 스레드 ,읽어주기 스레드가 순식간에 번갈아가면서 진행

## 라이브러리  
· 특정 기능을 수행할 수 있는 클래스 또는 함수의 집합체  
·· 특정 코드를 사용하기 위해 누군가가 미리 작성해 놓은 코드의 집합체  
·· 수학 라이브러리  
·· 애니메이션 라이브러리  
·· 문자열 라이브러리  

Ex. 삼각함수 라이브러리, 연산 전문 라이브러리 등

## API  
· 애플리케이션 프로그래밍 인터페이스  
· 응용 소프트웨어 프로그래밍 접합부  
· 응용 소프트웨어와 프레임워크 사이의 중간매체(방법)  
· 소프트웨어간의 통신 위해 메시지를 전달하는 방식 및 약속 등이 이미 결정된 것
---->앱에서 특정 기능에 접근하기 위한 방법을 미리 정해놓은 것  
“A라는 앱이 B라는 기능을 원하면 C라는 접근방법으로 오면 B라는 기능을 A에서 되게끔 해주겠다”  
· 특정 프로그램이라기 보단 특정 기능에 접근하기 위한 함수 및 창구의 개념  

Ex. 구글의 날씨 에이피아이, 페이스북의 로그인 에이피아이  

Ex. 날씨정보를 화면에 표시해 주는 애플리케이션  
· 날씨API 필요…”구글의 날씨API”   

· 컴퓨터와 API  
·· 사용자가 하고자 하는 모든 일은 운영체제에게 부탁해야 한다…”운영체제 API를 호출하는 것…” = “이 창구를 통해서 호출을 하면 내가 파일을 하드에 저장해주겠다”  
·· 시스템 내에 API가 속해 있으며, 프로그램과 API는 양방향으로 소통함… API<—>프로그램…  
· 서버와 API  
서버 프로그램 내에 API가 속해 있으며 API<—>클라이언트 프로그램 으로 양방향으로 소통함

## 프레임워크  
· 구조적으로 고정된 부분을 재사용할 수 있도록 하고 응용별 특정 기능을 추가적인 사용자 작성 코드에 의해 선택적으로 구현 가능하도록 하는 포괄적인 추상구조 그리고 이를 지원하는 소프트웨어 플랫폼(응용 소프트웨어를 돌릴 수 있는 플랫폼…코코아팟 플랫폼, 안드로이드 플랫폼 등)  

“이 시스템에서 응용프로그램을 실행하려면 공통적으로 마련된 기반을 우리가 만들어 놨으니 특정 창구를 통해 요청하면 수행할 것이며, 부가적인 기능은 사용자가 알아서 설치하면 됨”  

“운영체제는 대체적으로 프레임워크를 갖고, 응용프로그램을 생성하게 됨”  

“하나의 운영체제에서 쓸 수 있는 기능들을 코드로 작성해 사용자들에게 제공하는 것”  

· ios, 안드로이드 등 다양한 프레임워크가 존재  
· 라이브러리는 특정 기능을 표현하기 위한 작은 코드 꾸러미…  
· 프레임워크는 하나의 국가를 표현할 수 있는 더 큰 개념…  

Ex. 한국에 게임회사를 만들다면…  
기반시설이 없으면 도로, 우체국,인터넷 랜선 등을 다 만들어야 함…  
그러나 이미 기반시설은 다 있음…  
“회사를 차리면 되게끔 이미 시설을 다 만들어 놓은 것” "전기가 없으면 어디로 가고, 인터넷을 쓰려면 어디 가서 말하라고 절차까지도 다 구성해 놓은 것” = 프레임워크  
“회사 직무에 특화된 전문가들의 고용” —-전문가들= 라이브러리

▲ 프레임워크와 API, 라이브러리, 프로그래밍언어, 레퍼런스 문서  
· 프레임워크—국가 혹은 정부  
· 프레임워크의 하부 프레임워크 — 정부부처  
· API—국가기관…우체국, 경찰서 등  
· 라이브러리—직무전문가  
· 프로그래밍언어—국가 통용 언어  
· 레퍼런스 문서—국가 조직도 및 기능 설명서……프로그래밍을 위해선 ios, 안드로이드 등과 관련된 레퍼런스 문서를 봐야…”프레임워크는 어떤 것으로 구성, 어떤 언어를 쓰며, 어떤 API를 쓰는지, 어떤 클래스를 이루고 있는지의 서술”

## 코코아터치 프레임워크와 오브젝티브C  
· 코코아터치라는 나라 모양에 내가 원하는 일을 할 수 있는 기업을 세우는 것  
· 이 나라에서는 오브젝티브C 또는 스위프트라는 언어를 통해 의사소통을 할 수 있음

## 안드로이드 프레임워크와 자바  
· 안드로이드라는 나라 모양에 내가 원하는 일을 할 수 있는 기업을 세우는 것  
· 안드로이드라는 나라에서는 자바라는 언어를 통해 의사소통 할 수 있음

## 디자인패턴  
· 프로그램개발에서 자주 나타나는 과제를 해결하기 위한 방법 중 하나  
· 과거 소프트웨어 개발과정에서 발견된 설계의 노하우에 이름을 붙여 이후에 재이용하기 좋은 형태로 묶어서 정리한 것  
· 각 패턴들은 이전 개발자들이 써보니 쉽고 괜찮았던 패턴이지 진리, 정답은 아니다.  

Ex. 객체들끼리의 상호작용이 이뤄지면서 프로그램이 작동됨  
객체 생성 위한 클래스를 아무 기준 없이 만들어내면 프로그래머는 난감함…”이 클래스엔 어떤 기능까지 구현해야 하나” “한 번 만든 클래스의 코드를 다른 프로젝트에서 써야 편한데” “클래스 기준의 알맞은 생성에 대해 생각해야 함”

## MVC 패턴  
·· 모델: 데이터관리  
·· 컨트롤러:중재자  
·· 뷰:화면 표시  
···  클래스들을 3가지로 나눈 것…  
·· 모델 객체: 파일저장, 삭제, 기록  
·· 컨트롤러 :  모델 객체와 뷰 객체의 연결  
·· 뷰 객체 :  버튼, 텍스트, 웹뷰, 세이브버튼  
Ex. 사용자가 세이브버튼을 누르면 뷰의 세이버버튼 객체는 컨트롤러에게 사용자가 세이브버튼을 눌렀음을 통보…컨트롤러는 모델로 찾아가서 파일저장과 관련된 객체로 가서 명령…파일저장 객체는 다시 컨트롤러에게 저장되었음을 통보…컨트롤러는 다시 세이브버튼 객체에게 다시 통보  

· MVVM 패턴  
· Observer  
· Singleton  
· Prototype

## 레퍼런스 문서  
· API에 대해 서술해놓은 문서  
· 레퍼런스 문서는 특정 기능 API에 대해 적용하면 어떻게 구동되고 어떤 식으로 화면이 바뀌는 지를 다 적어둠

## IDE  
· 통합개발환경(Integrated Development Environment)  
· 개발하기 위해 필요한 것들을 다 모아둔 소프트웨어…컴파일 빌드 테스트툴 배포 등 소프트웨어 개발 위한 것들 모두 진행 가능

## SDK  
· 소프트웨어 개발에 필요한 도구의 모음(Software Development Kit)  
· IDE+프레임워크+툴+시뮬레이터  
· 프레임워크를 만드는 제조사들이 배포…Ex. iOS SDK Kit, Android SDK Kit   
· 프로그래머들이 자기네 환경에서 작동되는 프로그램들을 만들어야 하니 제조사들은 필사적으로 만듬

## 현업?  
웹프로그래머 디자이너 기획자 와 협업  
· 웹프로그래머  
·· 프론트엔드 백엔드 DB관리…다 가능한 사람=풀스텍…”셋다 깊게 할 줄 알면 최고의 개발자 중 하나”  
—-모바일도 할 줄 알고, 웹도 만들 줄 아는 풀스텍개발자를 찾는 CEO—-직원 절대 구할 수 없다…    

· 모바일프로그래머  
웹서버프로그래머와 마주…파이선 ASP JSP PHP 자바  
디자이너와 마주  
기획자와 마주 “별거 아닌데 내일까지 해줄 수 있어요?”  
다른 클라이언트 프로그래머(다른 Ios 개발자) 데이터 주고받기 형식을 앱들 간에도 통합을 해줘야 하므로 API 규격과 같은 사항을 논의…  
또 다른 모바일 프로그래머(안드로이드 개발자 등) 데이터 주고받기 형식을 앱들 간에도 통합을 해줘야 하므로 API 규격과 같은 사항을 논의…


