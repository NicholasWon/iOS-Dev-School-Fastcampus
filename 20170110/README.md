###DAY1.20170110

##컴퓨터공학 입문 코스##


###*각 용어의 정의 및 기본 정보*

* 프로그래머 : 프로그래밍을 하는 사람을 의미함

* 프로그래밍 : 프로그램을 만드는 행위

* 컴퓨터 프로그램 : 컴퓨터에 의해 실행될 수 있는 일련의 기능들 모음

* 컴퓨터 : 계산기 혹은 가산기
>컴퓨터의 시초는 암호해독, 수학연산으로, 복잡한 연산을 보다 빠르게 진행하고자 탄생되었다고 볼 수 있다.     
>컴퓨터의 탄생에는 2차대전 당시 수학자 앨런 튜링이 지대한 역할을 했으며, 그는 '빠른 계산'이라는 직면한 문제를 뛰어넘어, 나아가 생각할 수 있는 기계, 즉 인공지능의 등장을 내다본 바 있다.     
>다시 말해, 최초로 컴퓨터를 고안한 사람, 적극적으로 이용한 사람들은 수학자라고 할 수 있다.

###*컴퓨터의 종류에 대하여*

* 제 1세대 컴퓨터
진공관을 활용함.   
전선에 들어가는 전기로 0,1을 표현하기 어려운 상황에 따라 등장    
쓰다보면 진공관이 터지는 낮은 내구성을 보임
>애니악은 최초의 다용도 디지털 컴퓨터로, 1세대 컴퓨터의 예시이다.

* 제 2세대 컴퓨터
트랜지스터를 활용함.    
트랜지스터를 활용했을 당시까지는, 컴퓨터는 그 크기로 인해 가정에서 쓰기엔 부적합한 상황이었다.     

* 제 3세대 컴퓨터   
집적회로를 활용함.    
집적회로의 다리 하나가 기존 컴퓨터의‘선’하나를 대체할 수 있는 수준으로 이는 간단히 말해 0,1을 표현할 수 있음을 의미한다.   
>핸드폰에 있는 집적회로는 선배 세대 컴퓨터들이 갖춰져 있는 '100여개의 공장' 수준의 연산능력을 갖고 있다. 이는 간단히 말해 집적회로의 다리가 셀 수 없이 많기 때문임

###*컴퓨터의 구성*

* 하드웨어    
입력, 출력, 기억, 연산, 제어장치를 통칭함.   
컴퓨터와 그 주변을 구성하는 장치

* 소프트웨어     
소프트웨어는 프로그램과 명령어의 집합으로, 시스템 소프트웨어, 응용 소프트웨어
>시스템소프트웨어의 예시   
>운영체제, 로더, 컴파일러, 장치드라이버, 어셈블러, 링커, 유틸리티
커널: 하드웨어와 소프트웨어의 중개.   
>응용소프트웨어의 예시   
>응용소프트웨어는 애플리케이션과 동일한 의미이다.   
>워드,웹,스프레드시트,게임, OS 상에서 실행되는 모든 프로그램

* 기억장치   
기억장치는 주기억장치, 보조기억장치로 나뉘어진다.
>램 : 주기억장치는 속도가 빠르고, 전원이 꺼지면 데이터 지워짐. 램이 그 예시임
>
>보조기억장치 : 속도가 느리고, 전원이 꺼져도 데이터가 지워지지 않음. 하드디스크, CD, SSD가 그 예시임

* 제어장치   
CPU가 그 예시임.

###*컴퓨터의 구조*

>"컴퓨터의 동작원리를 알고 코딩을 하면 더 효율적이다."     
>***입문 수업 중***

* 하버드 구조.   
프로그램메모리와 데이터 메모리가 물리적으로 분리되어 있음.   
속도가 빠르다. 화살표가 겹치는 부분이 없어서 자료가 움직이면서 부딫치는 부분이 없기 때문임     
***따라서 병목이 없다***   
구성에 비용이 많이 들며 복잡하다. 이는 데이터가 가는 길을 일일이 다 뚫어주어야 하기 때문이다.    

![하버드 구조](https://github.com/gelb2/iOS-Dev-School-in-Fastcampus/blob/master/이미지%20전용%20폴더/harvardstructure.jpg?raw=true)

* 폰 노이만 구조   
명령어와 데이터가 하나의 메모리에 통합되어 있음.   
하나의 길(버스)을 통해 데이터가 움직인다.     
***따라서 빈번한 버스 병목 현상 및 메모리 속박 문제가 존재함***    
***하버드 구조보다 단순하고 싸다***    

>메모리 속박이란...   
>메모리는 CPU의 속도를 따라가지 못한다.     
>즉, 메모리의 읽기 쓰기 시간이 더 길기 때문에 CPU는 일을 하는 시간보다 메모리를 기다리는 시간이 길어짐을 의미함.    

![폰노이만 구조](https://github.com/gelb2/iOS-Dev-School-in-Fastcampus/blob/master/이미지%20전용%20폴더/VonNeumann_Architecture.jpg?raw=true)

* 폰 노이만 구조와 하버드 구조…더 나은 것은?    
폰 노이만 구조에서 데이터가 CPU와 메모리를 왕복할 때, CPU는 캐쉬 메모리에 일정 데이터를 복사해 둠…메모리가 데이터를 캐쉬메모리에 계속 밀어주고 CPU는 계속 처리하는 것….   
***이는 병목과 메모리 속박 문제를 완화시키기 위한 방법***

>CPU 외부는 폰 노이만 구조임…단 CPU는 내부적으로는 하버드 구조를 쓰고 있다
즉,최신 컴퓨터 아키텍처는 하버드 구조와 폰 노이만 구조의 결합임…CPU의 캐시 메모리 형상에 관여….   
컴퓨터의 전체적인 모양새는 폰 노이만 구조이므로 프로그래머는 폰 노이만 구조의 작동과 약점에 대해 알아야 함…

###*데이터의 표현 방식*
**“2진법” “8진법” “16진법”**

* 2진법.   
0011 —->0x23 + 0x22 + 1x21 + 1x20=3 (10진법)

* 16진법.   
0x : 16진수 앞에 붙음.   
>16진수의 숫자
0~9, A,B,C,D,E,F   
ex.0xAB78 ——>1010 1011 0111 1000

* 파일의 용량과 0,1
“파일의 용량은 결국 0,1이 얼마나 많이 들어갔느냐의 문제.   
Ex. 1024x768 해상도의 32 비트의 용량—-> 1024x768x32 

* 음수 표현 위한 보수.   
*. 1101 —->만일 맨 앞자리가 양수 음수를 표현하는 것이라면? 1은 양수 0은 음수…    

* 정수의 범위와 비트.   
32비트? —->232 만큼의 경우의 수를 표현 가능.   
1011 —->24 만큼의 경우의 수 표현 가능

* 실수를 표현하기 위한 규칙….   
IEEE754 : 실수를 컴퓨터에서 표현하기 위한 국제표준 규칙 중 하나.   
즉 0,1로 실수를 표현하기 위한 방법…”부호화” 의 하나.   
부호화=Encoding

* 인코딩: 데이터를 코드화 하는 과정

###*문자의 표현*

*ASCII*   
8비트 표현…8비트로 문자를 표현하기 위한 첫 문자 셋 (0~255…256개의 문자만을 표현 가능)….   
로마자와 숫자, 몇가지 특수기호만 아스키 코드표에 포함되어 있음…이 표에 있는 문자들은 모두 컴퓨터가 아는 0,1로 하드디스크에 저장 됨….   

>그런데 다른 컴퓨터에서 열었을 때 글자가 깨져서 나오는 이유?     
>저장할 때는 아스키코드 방식으로 저장을 했으나 다른 컴퓨터에서 다른 방식으로 불러온 것….   
>Ex. A는 아스키코드 상으론 79 인데 다른 코드에서는 79는 다른 문자인 것

* Unicode

* UTF-8.   
“세계적으로 국가 표준형은 없다…매우 많다”    
“지금 가장 표준적으로 많이 쓰이는 것은 UTF-8”

* EUC-KR.   
한글…완성형 인코딩 방식…    
국가 전산망을 거의 구성하고 있는 방식…

* CP 949	     
EUC-KR처럼 한글을 표현하기 위한 또다른 방식…EUC-KR과 더불어 한국 전산망을 구성하는 방식

> 각 방식마다 조합형도 있고 완성형도 있다….    
>—조합형 : ㄱ=1 ㄴ=2…..각 문자 별로 코드를 미리 만들어 놓은…10 100 —->ㄱ ㅏ 로 해석   
>완성형 : 가=1000 나=1001     
>완성형의 문제점…아직 만들어 지지 않은 문자는 쓸 수 없다….   
>Ex. 뷁 … 순우리말 이름…    
>완성형은 조합형보다 용량이 적다
>한자의 경우는 문자가 계속 만들어 지고 있기 때문에 계속 업데이트를 하는 중

* 문자 표현의 핵심     
컴퓨터는 0,1만 알고 있으므로 정보의 저장 출력을 위해선 부호화와 복호화가 필요하다

* 32비트와 64비트의 차이?      
> 32비트와 64비트의 차이는 한 번에 전송 가능한 데이터의 양을 표현한 것…한번에 0,1이 32개가 가냐 64개가 가냐의 차이….   
>ex.32비트 운영체제에서는 메모리를 4기가밖에 쓸 수 없는 이유…CPU와 메모리는 데이터, 명령어를 주고 받게 되는데 이런 것들은 램에 있다가 CPU로 들락날락 함…근데 컴퓨터가 램에 있는 데이터와 명령어를 찾아 들어갈 때…이 데이터와 명령어들은 각각 집주소와 같이 주소를 만들어 둔다…    
>
>명령어의 예시
>——>명령어: 철수가 영희네 집에 간다…—->철수네 집 주소, 영희네 집 주소를 CPU에 알려 주어야 CPU가 일을 수행…—->이렇게 숫자를 매길 수 있다…그러나 32비트 환경에서는 아무리 숫자를 매겨놓고 데이터를 축적해 놓아도 한 번에 움직일 수 있는 데이터 명령어의 양은 32비트가 한계이므로 램이 4기가 밖에 주소 할당을 못하는 것…
>때문에 64비트로 아키텍처를 전환하게 됨…그 동안은 비싸서 전환을 못한 것

* 2^32비트=4기가.   
* 2^64비트=192기가

* 비트수 제한으로 인한 또 다른 문제?    
—->IP주소의 고갈…기기마다 유일한 주소임…2012년도에 이미 끝남…
아이피주소의 예… 8비트, 8비트, 8비트, 8비트=255.3.5.150—->128비트,128비트,128비트,128비트 로 새로 만듬

* IPv4 : 32비트…현재 아이피 주소는 32비트로 사용 중
* IPv6 : 128비트…2012년에 이미 고갈되었기에 새로 만듬…

> 32비트와 64비트는 폰노이만 구조의 한계일 수도 있다…

* 컴퓨터의 연산.   
CPU는 가산기= CPU는 더하기 밖에 못함    
뺄셈은?보수 개념을 사용.    
곱셈은?계속 더한다.   
나누기는?계속 뺀다…

* 오버플로우.   
자리수가 넘쳐나서 0,1이 빠지는 것…자리수가 초과되어서 원하지 않는 값이 나오는 것….   
Ex. 00111     
Ex2. 0111+1 ——>1000…그런데 0은 양수, 1은 음수값…따라서 결과값이 8이 아니라 -8이 되는 것……싸이 유튜브 영상 조회수가 32비트에서 소화 가능한 숫자양을 넘어서 음수로 빠지는 경우가 이런 경우

* 언더플로우.   
자리수가 모자른 것

* 논리연산     
컴퓨터에게 0은 거짓, 그 외의 것은 참

* AND.   
논리곱…A&B    
둘 다 1이어야 결과값이 1

* OR.   
논리합…A|B    
둘 중 하나라도 결과값이 1이면 답은 1 

* NOT.   
~A…비트가 반전되는 것    
비트 not     
01010101 —> 10101010+1= 2의 보수 연산…Not은 보수 

* XOR.   
베타적논리곱 
A와 B가 서로 같으면 0이 되는 것.    
A^B

* NOR

* NAND

* 비트논리연산.   
각 비트별 0과 1계산    
0110&1101= 0100 —->비트논리연산…기호 한개.   
——-> 둘 다 1이면 1, 둘 중 하나라도 1이 아니면 0 이므로 0100.   
0110&&1101=true —->부울논리연산…기호 두개.   
——-> 둘다 어쨌든 0이 아니므로 둘 다 참—->그래서 답이 참

* 부울논리연산.   
참 · 거짓만이 답이 됨    
true&&false=false —->1111&&0000 = 0000.   
true&false=false —->1111& 0000 = 0000

* 연산을 이해해야 하는 이유?    
조건문—->부울논리연산 사용…참거짓 판별…ex. 성별, 몇살보다 적고 큰지, 포인트가 부족하니 알림창 띄우기    
x > 100 이면 ~~~True / False……“분기생성”.   
X >100 && Y > 50 이면 ~~~~ True/ False

* 논리합.   
X >100 || Y > 50 이면 ~~~~

* 비트논리연산.   
—OMR 카드    
—-문제마다 00100 , 10000, 01000 식으로 값을 줌.   
——-& 00100 —— “마스킹” —특정 자리의 비트만을 뽑아낼 때 사용.   
——-옵션제공 및 정보의 간소화 

* 비트마스킹의 예.   
바나나 0001 사과 0010 딸기 0100 복숭아 1000    
—->여러개를 고르고 싶다면… 0001 , 0010 , 0100 이라고 적는다면? “바이트 낭비”.   
——->바이트 낭비를 예방하려면? —-> 0011로 적고 받는 쪽이 체크하도록 ——> 비트마스킹 씌워서 체크 —->비트 4개를 가지고 4개의 정보를 완벽하게 확인 가능     
—-> “중복되지 않는 옵션값들 사용할 때 많이 사용함.   
——-ex. 진동 0001 , wifi 0010 ——>정보값들이 하드에 저장될 땐 옵션 플래그로 저장… 0011로 저장됨—->사용자는 진동과 와이파이를 동시에 켜놓았다는 것을 비트마스킹으로 알 수 있음…즉 두 값은 0001 이거나 0010 일 것임…즉 다 참임…이 다음엔 부울논리연산으로 응용 가능