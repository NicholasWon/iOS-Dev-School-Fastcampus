##20170123#

오브젝티브씨와 클래스 파일

헤더파일
· 클래스 타입 메소드, 컨스턴트 선언을 담음
· 임포트 지시어로 사용
· 프레임워크의 경우는 <framework>로 사용…프레임워크를 가져오면 해당 프레임워크에 있는 모든 헤더파일을 다 읽어올 수 있음
· 다른 클래스의 경우는 클래스파일.h로 헤더파일을 추가 가능함…m파일은 참조 불가
· 헤더파일이 임포트 되어야만 다른 클래스의 객체 생성 및 사용이 가능함

임포트와 @class 
두 클래스가 서로 임포트 하면 어떻게 되나?
서로 두개의 파일이 임포트를 하면 순환참조가 되어 한쪽이 무시되는 경우 생김…따라서 두 파일 양쪽에 임포트를 하면 안됨…따라서 클래스를 사용해야 함

@class의 사용
“해당 클래스의 이름이 존재한다는 것만 알리는” 것…해당 단어가 어떤 클래스의 이름인지 만을 알리는…
실제 사용 위헤선 @implementation 에 #import 시켜야 함
덧…상속은 무조건 헤더파일을 읽어오게 하는 것…엠파일은 무조건 은닉을 시켜주는 파일이므로…
즉 헤더파일을 임포트 해오는게 낫냐 아니면 클래스만 적는게 맞냐는 상황에 따라 생각해 봐야 함

엠파일
소스파일. 
엠엠파일
소스파일…엠파일과의 차이는 C++코드를 담을 수 있음…시쁠쁠 라이브러리를 가져다 쓸 수 있다는 의미…

오브젝티브씨 클래스의 특징
· interface  
“선언부”
상속관계와 프로토콜 선언
객체와 통신할 메소드를 선언
프로퍼티 변수를 선언
헤더파일 안에서 작성됨…주로 헤더파일에 작성되지만 엠파일에도 카테고리를 통해서 작성 가능
·· 인터페이스의 구조
선언을 하면…@interface 해당 클래스의 이름 : 부모 클래스
——>@interface Suv : Car
@property NSString *name;

(void)booting;

· implementation 
클래스의 메소드를 구현하는 실제 코드가 담겨 있음
엠파일에 작성됨
사실 안에서도 전역변수라고 해서 변수를 설정할 수도 있긴 하다…
퀵헬프,자세한 주석도 주로 구현파일에 작성하는 것이 좋다…
헤더파일엔 매우 간략한 주석만…

@implementation car

“인스턴스 메소드의 구현”…구현부는 임플리멘테이션 파일에 꼭 작성되어야 함…반대로 헤더파일에 작성되면 안됨…프로퍼티 역시 특정 값이 헤더파일에 작성되면 안됨
(void)booting
{NSLog(dsafadsfasdf);
}

@end    (@end는 implementation 종료)

객체화
alloc 메소드로 객체를 만들고, 그 객체를 초기화를 해왔다…그 이유는?
사실 초기화가 내부적으론 뭔지 모르나…메모리의 정리, 데이터 엉킴을 예방하는 것으로 추측함…또한 객체 생성시 바로 특정 값을 주는 것 역시 가능
객체 생성을 작성하면 각 프로퍼티의 값이 들어갈 메모리 공간이 할당됨…

메소드
· 클래스를 선언함…”상속관계와 프로토콜 선언”
· 컴퓨터가 수행할 명령어
· 인스턴스에 적용되거나 클래스에 적용되는 행동으로 나뉨
· 객체는 보통 객체 자신만 접근 가능한 정보를 포함하는데 메서드는 이 데이터에 접근하고 수정하는 방법을 제공함…”객체와 객체 간의 데이터를 주고받는 통신”…따라서 헤더파일에 메소드를 적어 두어야, 다른 객체가 다른 객체의 헤더파일에 적어둔 메소드를 통해 통신 가능

· 메소드의 구조
메소드 타입…+와 - 두 가지
반환타입…필수로 적는 사항…반환할 게 없다면 void로 적는 식
메소드명 doubleNum 등…
매개변수…타입과 이름을 적어줌…”파라미터”
메소드내용,,,{ }로 함수의 영역을 표시
return : 반환 값을 나타냄
(NSInteger)doubleNum:(NSInteger)number.     = 메소드타입,반환타입,메소드명:매개변수
{
//행동 :” 입력된 숫자를 2배 해서 반환해준다”
return number *2;
}

·· 메소드의 파라미터
파리미터는 쌍따옴표로 입력부분을 구분
타입과 변수명을 나눠씀
타입은 괄호 ()안에 작성
파라미터는 여러개를 작성도 가능 
매개변수는 해당 함수 안에서만 사용 가능

(NSInteger) sumNum1:(NSInteger)num1
                   num2(NSInteger)num2…
{
return num1 + num2;
//행동 : 입력된 두 숫자를 더해 반환해준다
}

·· 메소드와 반환값
결과값 반환은 반환타입과 같은 타입만 반환 가능…반환되는 값은 무조건 한 개
반환할 값이 없는 경우엔 void 타입으로 메소드를 작성해야 함…따라서 return 키워드를 쓸 필요 없다…
만일 다른 타입의 메소드인데 반환할 값이 없으면 return nil…”아무것도 없는 nil 이라는 값을 반환한다”는 의미

학점계산기 만들어 보기…
단순히 파일 하나에 과목값, 학생 이름, 계산 메소드를 다 넣기 보단…
학생, 과목, 계산기 등을 각각에 파일로 만들어서
조금 구조가 복잡해지더라도 파일을 여러개로 만들어서 확장성을 늘릴 수 있도록 고려해 봐야 한다
“객체지향의 기본 개념임”

캐스팅
“형 변환”
계산은 타입 A 로 하면 안에서 돌아가는 계산, 답도 타입 A가 되어야 함…따라서  NS, CGFloat 등 타입 들을 맞춰줘야 함
예를들어 4.25같은 실수 타입의 답을 나오게 하려면, 계산할 때는  NSUinteger 가 아니라  CGFloat으로 통일해야…
잘못 잡힌 타입을 하위의 다른 타입으로 다시 정정…’다운캐스팅’
코드 한 줄에서만 임시로 객체의 형을 바꾸고자 할 때…
ex.

id wing = [[Student alloc] initWithName:@“A”];
((Student *)wing).grade = 10;

wing 앞 부분이 형변환의 예시

도형 제작 실습
공통되는 인자는?

프로퍼티는 어떻게?
길이, 높이, 지름,

클래스는 어떻게?
각 도형들, 넓이, 직사각형 둘레, 원의 둘레, 부피

클래스1 넓이, 부피, 둘레, 원의 둘레

/*
 프로젝트 파일 70%까지 완료...
 계산에 필요한 인자들을 전부 프로퍼티 화 하여 클래스로 만든다 한다
 각 도형 별로 클래스를 만든다
 각 도형 클래스 들은 "프로퍼티 인자 클래스"를 상속받는다
 각 도형 클래스의 헤더,엠파일에는 관련 공식을 일일이 작성한다
 메인 엠파일에는 NSLog를 사용해 각자의 넓이, 부피를 띄우는 식을 만든다
 //상속되는건 프로퍼티나 매소드이지 각 프로퍼티 별 값이 아닌듯 하다...메인 파일에 프로퍼티값 다 적으니 상속이 안되나보네

메시징
메소드를 불러오고 싶다면 오브젝트를 메시징
메시지는 대괄화에 의해 표현
왼쪽은 메시지 받아야 할 오브젝트, 오른쪽은 보낼 메시지
[object message:param];

· 또한 메소드는 중복사용이 가능
car *tico = [car alloc];
tico = [tico init];

은 아래와 같다

Car * tico = [[Car alloc] init];

(NSString *)myName
{ Return @“jee”;
}

(void)printName:(NSString *)name{ NSLog(@“제 이름은 %@입니다.”,name); }

——메소드 두 번 호출
NSString *name = [self myName];
[self printName:name];  ——메소드 중복 사용의 예
[self printName: [self myName]];

· 초기화메소드
·· 인스턴스 생성시 객체의 초기화값을 정해줄 수 있다
·· 기본 초기화 메소드(init)은 NSObject에 정의되어 있다
·· init 메소드를 override 할 수 있다
·· 사용자 임의대로 Custom init메소드를 만들 수 있다
·· 초기화 함수 Return 값으로 instancetype을 반환해주어야 한다

· init 메소드의 오버라이드 
·· m파일..init 타이핑…자동완성 찾기…”쉽게 쓰는 법”
(instancetype)init
{
self = [super init];
if (self) {
//custom init 내용
}
return self;
}

· 커스텀 init 메소드
(instancetyp)initWithNum:(NSInteger)num
{
self = [super init];
if (self) {
//.h파일에 property num이 선언되어 있는 상태임
self.num = num;
}
return self;
}

클래스메소드와 인스턴스 메소드

· 클래스메소드
인스턴스 속성에 상관없이 클래스 자체에 필요한 행위를 정의할 때 사용
(id)classMethod;
· Ex.  Alloc…왼쪽에 클래스 이름, 오른쪽에 메소드 이름이 있는 구조 —-> 나오는 결과가 객체…[[car alloc] init]; 에서 init은 클래스 메소드가 아니다…car alloc 을 통해서 나오는 것은 객체이므로…init 은 객체에 가하는 메소드임…
·· 사용할때 클래스의 이름 적는다
Ex. 개발 시 클래스메소드 속 기능만을 구현하고 싶다면…만일 인스턴스메소드로 기능을 구현하려고 하면 항상 객체를 만들고  메모리에 할당해서 메소드를 구현해야 함…그러나 클래스메소드는 그냥 기능을 사용 가능…
때문에 클래스메소드는 굳이 객체를 만들지 않아도 클래스메소드를 호출해서 원하는 기능을 메인 파일에서 활용 가능
만일 인스턴스메소드만 활용하게 되면 상황에 따라선 메모리 낭비, 긴 작업시간 소요됨
·· 프로퍼티의 사용이 불가함

· 인스턴스메소드
인스턴스에서 사용되는 행외…대부분의 메소드가 해당…객체에게 가하는 메소드
(id) instanceMethod;

