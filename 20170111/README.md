## 20170111

### 컴퓨터의 역사  
* 수학자들이 만듬—이진수 사용  
* 진공관,트랜지스터,집적회로 순
* 소프트웨어  
-ios와 안드로이드 개발자들은 응용 소프트웨어 제작을 주로 할 것…

### 데이터 표현 방식  
* 아스키,유니코드,UTF-8,EUC-KR,CP949…  
* “텍스트 동영상 이미지 등을 어떻게 표현할 건가>—-코드를 만들고 부호화 시키는 것=인코딩

* 연산    
비트와 부울

* 논리연산  
And, or, not

### 운영체제  
* os  
* 응용 소프트웨어는 운영체제 위에서 돌아가므로 알아야 함  
* 이에 대한 이해가 없으면 제대로 앱을 만들고 운용하기가 힘들다  
* 시스템소프트웨어의 한 종류  
* 포함관계: 시스템소프트>운영체제>커널   
* 사용자와 응용프로그램 / 운영체제 / 하드웨어.   

>> 하드웨어를 제어하며 그것을 응용소프트에게 중재하는 역할이 운영체제의 역할….  

* 종류:리눅스 맥오에스 윈도우즈 아이오에스 안드로이드 유닉스 등….

### 운영체제는 왜 필요하나?
* 컴퓨터의 용도 증가…처음엔 군사용 수학연구 등이었으나…목적이 점점 많아지기 시작함…당시엔 운영체제가 없었음  
* 즉 하나를 구현하려면 쓰려는 목적에 맞게 계속 구동을 위한 모든 것을 프로그래밍 해 프로그렘을 만들었어야 함  ———>”비효율적임”  
* ”기본적인 것을 제공해주는 소프트웨어가 있으면 좋겠다는 생각 하에 운영체제를 만들게 됨  
* 운영체제가 범용적인 일을 하게 됨…전원 넣기, 드라이버 제어 등  
* “운영체제가 있으면 이제 사용자는 탄도 계산 프로그램과 같은 실사용 위한 프로그램만 만들면 된다”

### 운영체제의 갈래   
* 유닉스—BSD-맥오에스  
* 리눅스—안드로이드 우분투 Cent OS 페도라  
* 유닉스+리눅스=유닉스 계열 오에스 로 통칭

>> 리누스 토발즈: 리눅스…정확히 말하면 리눅스 커널 개발, 깃 개발
유닉스를 베껴서 만든 것이 리눅스…명령어도 유사하고 시스템도 유사함…

* 윈도우즈—윈도우즈 NT

>> 커널?    
>> 운영체제의 뼈대…안드로이드 우분투 센트오에스 페도라는 리눅스 커널을 가져다가 껍데기만 다르게 씌운 운영체제

### 운영체제가 하는 일

* 시스템 하드웨어 관리.   
사용자 프로그램 오류나 잘못된 자원 사용을 감시하고 입출력 장치 등의 자원에 대한 연산과 제어 관리    
ex.메모리에 대한 잘못된 접근, 시스템 자원 과다 점유시 프로그램을 강제로 꺼버리는. 것, 오류 발생하는 것…응용소프트웨어에서 뻘짓을 할 때 운영체제에서 강제로 죽이는. 것…”앱 쓰다가 튕기는 것”


* 시스템 서비스 제공     
사용자에게 컴퓨터의 프로그램을 쉽고 효율적으로 실행할 수 있는 환경 제공    
컴퓨터에 저장된 것들을 사람이 느낄 수 있는 가상의 공간처럼 표현해서 띄워주는 것

* 자원관리.   
컴퓨터 시스템 하드웨어 및 소프트웨어 자원을 여러 사용자 간에 효율적 할당 관리 보호.   
컴퓨터의 자원이라는 것은 한정되어 있으므로 필요한 개념.   
여러 실행중인 프로그램들이 자원을 사용하려 할때 각 프로그램들에게 잠시 대기, 우선순위 부여, 자원 사용량 할당 등을 효율적으로 관리하는 것이 운영체제의 역할…ex.게임하며 음악 듣기, 다운로드 받기, 백신검사 하기 등….   
“개발자가 주목해야 할 부분은 자원관리 분야”

## 자원관리와 프로세스

* 중앙처리장치: 시피유  
* 주기억장치:프로그램(프로세스)  
* 보조기억장치:프로그램  
* 우리가 프로그램을 실행하는 순간 보조기억장치에 있던 프로그램이 주기억장치로 넘어와 프로세스가 된다…0과1을 읽어서 시피유가 일을 하게 하려면 우선 메모리에 먼저 올라가야(메모리에 명령어가 올라가야)한다…이 올라가는 것을 “프로세스가 되었다”고 한다…”살아있는 프로그램”이 되는 것.   
Ex. 게임의 “로딩중”  
* 주기억장치는 컴을 끄면 내용이 사라진다…그래서 보조기억장치를 사용..  


### 프로세스의 상태  
* 생성 : 프로세스가 생성됨  
* 준비  : 중앙처리장치에 의해 프로세스가 실행 되기를 기다린다  

>> 준비 과정이 필요한 이유? 씨피유는 한 번에 한가지 일만 할 수 있다 —> 그러므로 다른 일들은 시피유에 선점된 일을 메모리에서 기다려야 함 —>기다리는 일 들은 준비 단계로 대기하는 것   

>> 시피유 클럭(2.7Ghz)의 의미? 초당 해결 가능한 명령어의 수…  
2.7ghz= 2.7x2의 10승(KB)x2의 10승(MB) x 2의 10승(GB)  

* 실행 : 중앙처리장치에 의해 프로세스가 실행된다  
* 대기 : 어떤 사건이 일어나기를 기다린다  
* 종료 : 중앙처리장치에 의해 프로세스가 실행 된다  

*  프로세스 상호작용 종합
생성—>준비  
준비—>실행  
실행—>준비  
실행—>대기—>준비  
실행—>종료  

### 프로세세 스케쥴링  
* FCFS(퍼스트 컴 퍼스트 서브)…준비 상태 큐에 도착한 순서에 따라 차례로 시피유를 할당…하지만 이미 할당된 업무가 엄청 오래 걸리는 업무라면?…”다른 방식이 필요함”  

* SJF(쇼티스트 잡 퍼스트)…실행시간이 가장 짧은 프로세스에게 먼저 시피유 할당, 평균 대기시간 가장 적은 알고리즘, 실행시간이 긴 프로세스에 밀려 무한 연기상태 발생 가능  
“짧은 프로세스만 먼저 계속 가면 다른 것들은? 다른 방식이 필요함”

* 라운드 로빈 스케쥴  
제한시간(5분)이 지나면 맨뒤로 보내버리고 다른 일을 처리하는 것…컴퓨터에게 오분은 거의 영원의 시간…사람이 느끼지 못하는 찰나의 시간이 할당됨  
시분할 시스템을 위해 고안된 방식  
FCFS 기법의 변형  
각 프로세스는 시간 할당량 동안만 실행  
완료되지 않으면 다음 프로세스에세 시피유를 넘겨주고 준비상태 큐의 가장 뒤로 배치  
할당된 시간이 클수록 FCFS와 비슷함  
할당시간이 작을 수록 문맥교환과 오버헤드가 자주 발생…컨텍스트…즉 순서를 바꾸는 것 도 하나의 “운영체제가 하는 일”이기 때문  
“그런데 VIP급의 중요한 프로세스도 기다려야 하나? 우선순위 부여가 필요하기에…”

* 프라이오티 베이스드 스케쥴링  
프로세스마다 우선순위 부여  
우선순위가 동일한 경우 FCFS 기법으로 할당  
가장 낮은 순위를 부여 받은 프로세스의 무한연기가 발생할 가능성 생김  
“하지만 결국 절충할 필요가 생김…그래서 운영체제들을 보면 다양한 벙법을 섞어서 사용함”

* 멀티 큐 스케쥴링  
프로세스를 특정 그룹으로 분류 시 그룹에 따라 각기 다른 준비단계 큐 사용  
“대기열의 스케쥴링  
준비상태 큐 마다 다른 스케쥴링 기법 사용 가능  
다른 준비상태 큐로 이동 불가  
하위단계 준비 큐에 프로세스를 실행하는 도중이라도 상위단계 준비상태 큐에 프로세스가 들어 오면 상위단계 프로세스에세 시피유를 할당


### 작업관리자와 활성상태에서 볼 수 있는 프로세스  
* 프로세스와 스레드?…각자 우선순위가 있다…운영체제에서 우선순위를 주기도 한다…알집에서도 프로세스 우선순위 낮추기 높이기가 있다  
* 사용자가 별 일을 안하더라도 상당히 많은 프로세스가 돌아가고 번갈아가면서 일처리를 하고 있다

## 주기억장치의 관리

* 단순관리  
메모리에서 주소를 관리, 매핑하는 것도 운영체제가 하는 일….   
Ex. 특정 프로그램이 메모리를 더 쓰게 요청할시 승인, 너무 많이 쓸때 제한하기 등…다다익램은 메모리에 프로그램이 올라와서 프로세스가 되어야 하므로 나오는 개념…  
”최소한 게임은 메모리에 올라와서 이 정도의 공간을 활용해야 한다 : 최소 메모리 사양…메모리가 광활하면 1스테이지 중이더라도 2,3 스테이지를 미리 메모리에서 불러오기가 가능하므로 다다익램이라는 말이 나오는 것”   
“우리가 쓰는 모든 프로그램들은 모두 프로세스로서 먼저 메모리에 올라와야 기능할 수 있으므로…”  
“특정 프로그램이 너무 많이 메모리를 쓰면 운영체제는 쓸데없는 리소스를 지우거나 하는 식으로 사용공간을 줄이라고 프로그램에 요청…프로그램이 말을 듣지 않으면 몇 번의 경고가 등장하고, 궁극적으론 프로그램을 죽이는 방식으로 대응…  
개발자는 경고가 등장하면 특정 리소스 A B C를 우선 제거하는 식으로 프로그램이 대응하도록 프로그램을 짜야 한다…  
죽여도 되는 프로세스와 죽이면 안되는 프로세스는 운영체제가 판단한다…  
만일 사용자가 실행한 프로그램이 문제…즉 개발자가 만든 프로그램과 앱이 문제이면 운영체제가 죽인다”

*  가상메모리  
“보조기억장치를 주기억장치처럼 활용”  
메모리는 제한되어 있음…그런데 프로그램을 메모리가 부족하다고 무조건 죽이는게 타당하나? 그래서 보조기억장치(하드디스크)의 남는 공간을 띄어서 주기억장치(램)처럼 활용해보자는 발상…  
그러나 주기억장치의 속도는 보조기억장치보다 매우 빠르다…당장 메모리에서 필요없는 것이나 중요도가 낮은 것들은 보조기억장치에서 돌아가게 해보는 것이 기본 메커니즘   
>> 내 메모리 양이 크면…16기가 32기가…? 가상메모리를 끄는 것이 더 낫다…가상메모리는 어쨌든 보조기억장치보다 속도가 느리니까

### 파일관리
*  파일관리의 상호도  
응용프로그램<—(파일 입 출력 요청)—>운영체제<—(파일 입 출력 처리)—>보조기억장치

*  파일관리와 운영체제의 역할  
운영체제가 없다면 사용자는 하드디스크에 0 1을 쓰는 법을 직접 다 배워야 한다  
사용자가 작성하는 코드와 명령은 모두 운영체제로 보내진다…하드와 메모리로 보내는 것이 아니라…  
파일 읽기 쓰기 소리 출력하기 등 모든 것은 운영체제를 통한다  
>> Ex. 운영체제에서 볼 수 있는 “파일경로”는 가상의 개념…사실 하드에는 0,1이 마구잡이로 섞여 있다…폴더A를 만든다고 해서 하드에 A라는 공간이 일관적으로 할당되는 것이 아님…폴더A를 사용자가 만들면 하드디스크에 폴더A에 해당하는 자료는 몇 번지 어딘가에 있다고 위치를 맵핑해 주는 것  

* 운영체제마다 파일관리 방법은 다르다  
맥에 씨드라이브, 윈도우에 루트가 있나? 없다  
윈도우에서 쓰던 유에스비는 맥에서 못쓰고 맥에서 쓰던 유에스비는 못쓴다…  
맥에는 조각모음이 없다…윈도우에선 하드 사용공간을 쪼개고 쪼개고 데이터를 빈 공간에 여기저기 넣는다…”하드디스크 조각…여러 군데를 접근해야 하니 느려지는 것…하드디스크는 데이터를 다 찾으려면 한 바퀴 회전해야 한다…램은 랜덤 엑세스 방식이기에 주소만 알면 바로 즉각적 접근이 가능하다…SSD도 랜덤 엑세스 방식과 유사함…SSD가 조각모음을 하면 안되는 이유도 랜덤 엑세스 방식에 있다”…  
**이유는 파일관리 방법이 시스템마다 상이하므로**

* 파일시스템  
1.유닉스  
**유닉스 파일 시스템**

2.리눅스  
**확장 파일 시스템, ZFS, XFS**

3.맥오에스  
**HFS, HFS+**

4.윈도우  

**FAT, NTFS**

### 커널  
* 운영체제의 핵심  
* 운영체제의 정체성  
* 운영체제는 커널을 감싼, 커널을 갖고 있는 껍질  
* 보안 자원관리 추상화  
* 운영체제는 메모장, 바탕화면 보여주기, 가상시스템 제공, 프로세스 자원관리 등을 하고…운영체제의 핵심적 역할…즉 하드웨어 직접 관리, 하드 파일 읽기 쓰기 등은 커널이 제공
  
>> 커널이 같으면 같은 계열의 운영체제라고 볼 수 있는 이유….   
>> 리눅스 우분투 센트 OS는 각각 하드웨어 직접 관리, 파일 관리는 같은 방식으로 하기로 동의한 것…각자 게임특화, 모바일 특화 등으로 나뉘는 것
>>        
>> 안드로이드가 삼성 엘지 펜텍 등으로 오에스가 조금씩 다르게 보이는 이유?     
>> 젤리빈 등 신버전이 출시되면 출시시기가 다 다른 이유?     
>> 커널은 공유 하지만 껍데기가 다르므로…예를 들면 삼성 안드로이드 폰은 삼성페이 티스토어와 같은 운영체제의 껍데기가 다르기 때문에 제조사별로 커스터마이징을 해야 하는 것…사람들이 크랙하는 경우엔 티스토어 같은 껍데기를 날리는 것…

### 컴퓨터의 동작
**주요 변수들**   
1. 사용자     
2. 입력장치  
3. 운영체제   
4. 앱   
5. 주기억장치    
6. 연산장치   
7. 제어장치   
8. 출력장치  

*  앱실행과 데이터 흐름 도식 및 순서  
사용자의 클릭—>입력장치—>운영체제—>”화면의 어느 좌표에 사용자가 클릭이 되었다”—>”음악프로그램의 어느 범위에 속해있는지 파악”.   
—->오에스는 이것이 어느 버튼인지 파악함—>앱이 음악파일을 오에스에게 다시 요청—->”음악 파일 나에게 가져와줘”—>오에스는 하드디스크를 뒤져서—->   
찾은 음악을 메모리에 올림—->운영체제는 앱에게 음악을 올렸다고 알림—->앱은 메모리에서 음악을 읽어옴—->   
앱은 운영체제에게 스피커를 통해 재생해 줄 것을 요청—->오에스는 스피커에 재생 명령어를 보냄—->재생      
**CPU 와 램 오에스 간의 소통은 도식 안에서 간헐적으로 빈번하게 일어남**    
**세부적으로 더 들어가게 되면 도식은 더 복잡해질 것**    
**개발자는 클릭 및 터치 후 발생할 일 들을 상당 수준 도식화 해서 생각해 볼 수 있어야 함**  

* 로드: 프로그램이 메모리에 올라가는 것…  
* 버퍼: 동영상이 메모리에 올라가는 것 “버퍼와 컵”—동여상 보다가 갑자기 두 시간 뒤로 넘기면 뚝 끊기는 이유? 버퍼에 담긴 동영상 데이터가 없으니 컴퓨터가 급하게 불러오는 것…  

>> CPU의 효율적 활용?    
>> 각 코어 별 부하를 늘리느냐 줄이느냐에 대한 것도 고려해 개발을 해야…  

### 알고리즘과 자료구조
**알고리즘이란**.   
1. 문제해결 위한 절차 및 방법    
2. 어떤 문제를 해결하기 위한 여러 동작들 모음. 
3. 답을 찾는 것이 아닌 과정을 기록 확인하는 것.    
4. 문제해결력과 코딩교육은 하등 상관이 없다.   
>> Ex. 목마름과 물 끓이기, 레몬차 마시기까지 해결할 일련의 작업 흐름…답을 찾는 것이 아닌 과정을 기록 확인하는 것  
Ex.2. 특정 기능을 구현하려면 어떤 방향으로 접근하고, 어떤 과정을 거쳐야 하는가를 생각하고 실행하는 것  

* 알고리즘의 예시  
**테트리스의 헥심은 한 줄 두 줄 씩 없애기, 맨 윗쪽까지 안닿게 하기**.   

>>어떻게 안전하고, 효율적으로, 빠르게 줄을 없앨 수 있을까?  
>>ㄴ자만 나오면 위치, 배열을 조금씩 조정한다  

**여행가방을 꾸리려면?**

>>작은 물건부터, 큰 물건 부터, 잘 안꺼내는 물건 부터 넣기 등 방법이 다양함…  
물건을 준비하는 과정부터, 넣는 순서, 배열도 다 달라진다

### 자료구조  
* 자료를 효율적으로 이용할 수 있는 방법론  
* 데이터를 구조적으로 표현하는 방식

**자료구조의 예시**.   

* 테트리스의 헥심은 한 줄 두 줄 씩 없애기, 맨 윗쪽까지 안닿게 하기.   
>>어떻게 안전하고, 효율적으로, 빠르게 줄을 없앨 수 있을까?  
>>ㄴ자만 나오면 전부 ㅁ자로 바꾼다

* 여행가방을 꾸리려면?  
-- -- 작은 물건부터, 큰 물건 부터, 잘 안꺼내는 물건 부터 넣기 등 방법이 다양함…  
-- —바지와 셔츠는 둘둘 말고, 각잡아서 접어서 넣는다, 카메라는 보호케이스에 넣는다

*  알고리즘과 자료구조의 핵심  
**테트리스 : 적절한 모양의 블록(자료구조)를 요리조리 돌리고 옮겨(알고리즘)서 게임을 함**  
**가방 꾸리기 : 효율적으로 물건의 부피를 줄이고(자료구조) 꺼낼 순서에 맞게(알고리즘) 차곡차곡 정리해서 넣으면 많이 들어간다**

### 자료구조의 종류  

**자료구조는 메모리 안에서 처리되야 할 데이터 안에서 표현되어야 할 방식을 정리.**   

1. 원시구조 : 정수, 실수, 문자…하드 어딘가에 3, 3.0, a 이런 것들이 하나씩 그냥 동떨어져있는 것  
2. 선형구조 : 배열, 연결리스트, 스텍, 큐, 덱  

**배열**   
데이터를 일렬로 순서대로 놓은 것…처음에 신발장을 30명 분으로 만들어 놓으면 이 크기를 늘리거나 줄일 수 없는 방식…이미 메모리에 30명 분을 할당을 받은 상태…더 받거나 덜 받거나 불가능함…   
“크기변경 불가함” “칸 갯수, 크기가 정해져 있으므로 컴퓨터는 각 위치의 데이터를 빠르게 파악…즉 메모리 주소를 빠르게 파악…100번째 인덱스를 찾아가기가 매우 쉬움…” “각 칸 별 데이터를 바꿀 수는 있으나 해당 칸을 다른 프로그램이 쓸 수 있게 할당하는 것은 불가함”  


**연결리스트**.    
배열이 가진 문제점을 개선하고자 등장…신발장이 통짜가 아닌 한개씩 조립식으로 만듬  

**단순 연결 리스트**.    
1번 신발장 2번, 3번을 각각 줄로 연결…”메모리에서 각자 가지는 주소…각각의 데이터들은 꼬리표로 다음 데이터의 위치를 갖고 있음…2번 데이터가 갑자기 사라지면…2번 데이터는 1번 데이터에게 “1번 데이터 다음은 이제 3번 데이터”라고 정보를 주고 사라지면 된다…2번 데이터가 사라진 자리엔 다른 프로세스가 들어올 수 있다…31번 데이터가 생기면 30번 데이터에 “30번 다음은 31번”이라고 정보가 주어지면 됨”  
“그러나 특정 데이터를 찾으려면 0번 데이터 부터 찾아야 함…16 17 같은 특정 데이터에 바로 접근 불가…즉 속도가 느림”  
“다음 데이터는 알지만 이전 데이터는 뭔지 모름” “다음 데이터가 무엇인지를 데이터가 알아야 하므로 그 꼬리표 만큼의 공간소모가 생김”  
**"데이터 하나당 주소를 부여하는 것"**.    
**"추가 삽입, 삭제가 가능"**
>>단순 연결 리스트의 문제점
>>1. 헤드 노드를 참조하는 주소를 잃어버리면 데이터 전체를 못쓰게 됨
>>2. 다음 노드를 참조하는 주소 중 하나가 잘못되면 그 부분의 뒷쪽 자료부터 유실

**이중 연결 리스트**  
“꼬리표를 두개 만드는 것…”.   
“즉 데이터가 자기 앞 뒤 데이터의 주소를 모두 아는 것…”  
“100번째 데이터를 찾고, 그 다음에 99번째 데이터를 찾고자 하면, 단순연결리스트는 0부터 99까지 다 다시 찾아봐야 하지만  이중연결은 100이 알고 있으니 99를 더 빨리 찾을 수 있음”  
**"다음 노드의 참조 뿐만 아니라 이전 노드의 참조도 같이 가리키게 함"**.   
**"뒤로 탐색하는 것이 더 빠르다"**
>>이중 연결 리스트의 문제점
>>1.관리해야 할 참조가 두개...삽입이나 정렬의 경우 작업량이 더 많다...자료구조의 크기가 더 커진다

**원형 연결 리스트**  
단순 연결 리스트와 유사하나 맨 뒤 데이터가 맨 앞 데이터에 대한 꼬리표를 갖고 있는 것  
자료들의 순서 없이, 순환하면서 뭔가를 찾아야 할 때 사용하는 방식  
**"단순 연결 리스트에서 마지막 원소가 처음 원소를 가리키게 하면 원형 연결리스트가 됨"**.   
**"이중 연결 리스트의 처음과 끝을 이으면 이중 원형 연결 리스트를 만들 수 있음"**
**"스트림 버퍼에 많이 사용"**.   
**"이미 할당된 메모리 공간을 삭제하고 재할당하는 부담이 없어서 큐를 구현 할 때도 적합"**

>> 성능 면에선 배열과 비교해서 안좋지만 삽입과 삭제 위해서는 더 나은 방법임  
하지만 요즘은 컴퓨터 성능이 좋아져서 배열을 쓰지 않음…하지만 게임, 한정된 하드웨어 자원을 써야 하는 곳에선 배열을 여전히 사용 중  
**오브젝티브 씨에서 말하는 어레이는 “배열”을 의미함**.   

**청크 리스트**.   
배열 장점 + 리스트 장점.   
리스트의 맴버가 배열임.   
**청크 리스트의 발전형 == B+Tree**  

### 자료구조 디테일

* 스택.   
**"Last In First Out"**  
“자료를 추가하거나 뺄때 어떻게 하지?”  
“자료를 일련의 규칙으로 쌓아둔 것”  
자료를 1,2,3 번으로 이름을 정해서 넣고 맨 마지막에 들어온 자료부터 뻬내는 식
  
>>Ex. 뒤로가기 버튼을 누르면 가장 마지막 홈피 이전 페이지 부터 역순으로 뜬다  
>>Ex. 2 : 설정<—와이파이<—와이파이 고르는 창  

이들 데이터는 내부적으로 리스트로 연결되어 있을 확률이 높다...  
**“자료쌓기는 푸쉬, 자료 꺼내기는 팝 으로 명칭”**  

* 큐(Queue).   
**"First In First Out"**  
“큐는 작업대기열을 의미” “여럿이 서있는 줄을 의미”  
“맨 먼저 들어온 데이터가 맨 먼저 빠져나감”   
“작업대기열에 가장 많이 사용”—-Ex CPU 스케쥴링  
**“자료 넣기는 풋, 자료 꺼내기는 겟 으로 명칭”**  

* 덱(Dequeue)  
**"스텍과 큐의 합"**
스택과 큐를 활용하기에 애매한 경우엔 스택과 큐를 합침…  
“순차적으로 쌓인 자료를 앞에서도 뒤에서도 데이터를 빼오기가 가능”  
**“단 쌓인 자료의 중간을 빼오기는 불가능”**  
“Double ended Queue 라고도 명칭”  

### 비선형구조 : 트리, 그래프  

* 트리  
**리스트의 변화**
깃의 브렌치와 유사   
**마인드맵, 가계도, 조직도와 같은 형태의 리스트**.   
**데이터간의 상하구조 관계가 있다. 즉 종속관계를 표현한다**.    

**가계도처럼 부모와 자식 관계를 형성함**.   
   
**비선형구조로 하나의 결과만이 있는게 아님**

>> ex
>> 폴더 디렉토리, 탐색기, 맥 파인더 등 에서 사용
>> Ex. ㄱㄴㄷ 순으로 1차로 자료 분류, ㅏㅑㅓㅕ 순으로 2차로 자료 분류 —-> 갸오오 라는 자료를 찾을 때 매우 신속하게 찾기 가능…만일 일렬로 자료를 연결했다면 맨 처음 데이터부터 하나 하나 찾아야 할 것 —-> 
>> **“검색기능에서 강점”**
  

**메모리에 올려서 자료를 효율적으로 빠르게 찾고 관리해야 하는 경우에 사용**   
  
>> 자식 노드 즉 시블링 노드 끼리는 연결되지 않음…
>> 
>> 시블링 노드 차일드 노드 루트 노드는 각각 브랜치로 연결됨 
>>  
>> 부자 관계 : 루트 노드>차일드 노드>시블링 노드.   

* 트리순회

트리 구조에서 각 노드를 체계적인 방법으로 한 번만 방문하는 과정. 노드를 방문하는 순서에 따라 분류됨

##### 전위순회

1. 진행순서 : 노드를 방문한다
2. 왼쪽 서브 트리를 전위 순회함
3. 오른쪽 서브 트리를 전위 순회함

> 전위 순회는 깊이 우선 순회라고도 부름

##### 중위순회

1. 진행순서 : 왼쪽 서브 트리를 중위함순회함
2. 노드를 방문함
3. 오른쪽 서브 트리를 중위 순회함

> 중위 순회는 대칭순회라고도 함

##### 후위순회
1. 진행순서 : 왼쪽 서브 트리를 후위 순회함
2. 오른쪽 서브 트리를 후위 순회함
3. 노드를 방문함

* 그래프  

1. 최상위 루트가 보이지 않음..."상하관계가 없음...루트 노드가 따로 정해져 있지 않음
2. 페이스북 그래프와 유사…”여섯다리만 건너면 나도 연예인과 안다”
3. 서로간의 관계를 묘사해야 할 때 사용..."연결관계, 데이터들의 관계"  


> Ex. 빅데이터…새로나온 개념도 아니고 예전부터 다들 쓰여온 것… 

##### 트리와 그래프  
트리는 상하관계가 있고, 그래프는 상하관계가 없다…트리는 관계에 대한 설명에 더 가까운  
그래프는 각 데이터가 마구 몇가지나 뻗어나갔는지가 중요한 개념은 아니다…그래서 가지가 여러개라고 해서 그것이 “중추 데이터”라고 보는 것은 아님…그래프상에서 어떤 데이터가 중요한 데이터인지는 사용자가 판단해야 할 문제…  


> Ex. 그래프에서 왕따 데이터를 찾느냐, 여왕벌같은 데이터를 찾느냐는 결국 사용자가 판단하는 문제…   

## 알고리즘  
* 일을 처리하는 순서 및 방법  
* 자료의 검색 및 탐색이 중추적인 방법 중 하나…”대학에서 가장 먼저 배우는 것은 검색 및 탐색 알고리즘”  
* 알고리즘 전에 자료구조에 대해 정확히 알아야…자료를 제대로 쌓아 놓아여 쉽고 정확하게 찾을 수 있으므로…  
* 대표적 알고리즘 : 정렬 탐색 재귀 등  

##### 정렬 알고리즘
* 무작위로 정렬된 막대기들을 길이 순으로 정렬…사용 가능한 정렬법은 여러가지
* 분포도와 가지고 있는 자료의 양, 형태에 따라 알고리즘이 다르다...ㄷ상황에 따라 알고리즘 선택해야 함


##### 정렬 알고리즘 종류
* 선택정렬 : 전체 한 번 쭉 읽고 가장 작은 막대를 선택해서 정렬, 다시 한번 스캔해서 두 번째로 작은 막대를 선택해서 정렬…무한 반복  

> 전체를 읽고 가장 작은 것을 앞으로 반복...작은거 왼쪽으로 보냄

* 버블정렬 : 기준과 옆과 비교해서 크면 뒤로 밀어주는 형식 …민 뒤에 제일 큰게 오게 되고 계속 반복…선택정렬과 달리 옆의 데이터와만 비교…  

> 처음부터 n번째 앞뒤로 비교를 반복...큰거 오른쪽으로 보냄

* 삽입정렬 : 선택한 기준 데이터를 가지고 기준보다 작거나 큰 데이터들 사이에 끼워넣음…

> 앞뒤 중앙의 자리에 삽입해줌..앞뒤 중간값에 비교한 후 맞는부분에 넣음...왼쪽으로 보낸다
> a번째 원소를 1부터 a-1까지와 비교해 적절한 위치에 끼워넣고, 그 뒤의 자료를 한 칸씩 뒤로 밀어내는 방식...자료구조에 따라선 뒤로 밀어내는데 걸리는 시간이 크며, 작은 것이 뒷쪽에 몰려 있으면(혹은 내림차순의 경우에 큰 것이 뒷쪽에 몰려 있으면)효율성이 떨어짐...  

* 병합정렬 : 일정 구간을 나눠서 먼저 정렬하고 다시 일정구간 나눠서 먼저 정렬…그리고 먼저 정렬된 것들을 합쳐서(Merge)다시 정렬…구간을 나눠서 다음에 정렬할 것을 삽입정렬을 하냐 선택정렬을 하냐도 달라짐…어쨌든 나중에 합쳐서 다시 정렬하는 것…  

> 원소 갯수가 1 혹은 0이 될 때까지 두 부분으로 자른뒤 자른 순서의 역순으로 크기를 병합해 나감...병합된 부분 안은 이미 정렬되어 있으므로 전부 비교하지 않아도 제자리를 찾을 수 있음...
> 성능은 퀵정렬보다 떨어지고, 데이터 크기만한 메모리가 필요함...

> 그러나 데이터 상태에 별 영향을 받지 않는다는 것이 장점

* 퀵정렬 : 중간 기준점을 나눠서 그것보다 큰 것은 오른쪽 작은건 왼쪽으로 나눠서 정렬하고, 이를 계속 반복해서 정렬하는 것…평균적으로 가장 빠른 정렬속도…그러나 기준점을 잘못 잡거나(제일 크거나 작거나), 자료의 크기가 비슷비슷할때(기준점 잡기 애매하니)에는 매우 느린 속도… 

> 중심점을 잡아서 작은것은 왼쪽 큰것은 오른쪽으로 보낸다...평균적으로 가장 빠르다

* 힙정렬 : 원소들을 전부 힙에 삽입하고, 힙의 루트에 있는 값은 남은 수들 중에서 최소값을 가지므로 루트를 출력하고 힙에서 제거한디...힙이 빌 때까지 2의 과정을 반복한다 

## 가장 좋은 정렬법이냐는 자료의 형태, 자료구조에 따라서 달라진다  

## 면접에서는 “~~한 자료가 있을때, ~~한 코드가 있을 때 어떤 알고리즘을 사용하는 것이 좋을 것이며, 어떠한 좋은 결과 혹은 문제점이 발생할 것인가?”로 물음  

## 각 알고리즘 들은 혼합해서 사용 가능

# 시간복잡도  

* 알고리즘이 실행되는데 소요되는 시간 분석  


> Ex. 선택정렬로 정리해야 할 데이터가 n개라면 데이터를 읽는 속도는 n번, n-1, n-2….1번…즉 n(n+1)/2번 엑세스 해야 함  

· 점근 표기법(Big O 표기법)  
알고리즘으로 정렬 시 최악과 평균과 최선의 시간을 표기하는 법…**최대시간의 예측**
> 가장 중요한것은 최악이므로 시간복잡도 그래프를 Big O 표기법으로 표기  
Big O 표기법은 최악의 경우를 표기함  

* 정렬 알고리즘의 시간복잡도   

**“퀵정렬이 평균적으로 가장 빠르다”**
· 탐색 알고리즘의 시간 복잡도  

##### 공간복잡도(메모리를 차지하는 효율)

* 기존 배열을 사용하느냐 아니면 새로운 배열을 만드느냐
* 배열을 잃게 되고 얻게 되는 것이 무엇인가
* 배열인가 리스트인가
* 얼마나 많은 메모리를 차지하는가

##### 데이터베이스

* 대부분 보조기억장치와 관련
* 여러 사람에 의해 공유되어 사용될 목적으로 통합하여 관리되는 데이터의 집합
* 통합된 정보들을 저장하여 운영할 수 있는 공용 데이터들의 묶음
* 모두를 위한 데이터체계
* 하나하나의 데이터 묶음은 테이블이라고 부름

##### DBMS

* DBMS...DataBase Management System...DB와 다름
* 데이터베이스에 접근할 수 있는 기능을 제공하는 소프트웨어...데이터베이스계의 운영체계
> MySQL, PostgreSQL, SQLite, MariaDB 등...

##### SQL

* Structured Query Language
* DBMS를 통해 데이터를 관리하기 위한 구조화된 질의문을 작성하기 위한 언어
* 추가, 삭제 명령을 SQL을 통해 함

##### No Sql

* SQL을 쓰지 않아도 되는 DBMS, 관계형이 아님
* 사용자에게 쉽게 접근

## TEST Review  

▲ 운영체제의 역할  


* 컴퓨터의 하드웨어와 소프트웨어의 관리  
* 사용자의 명령(Ex. 클릭)을 1차저으로 받아서 사용자 프로그램에 전달…또한 역순으로 프로그램—>운영체제—>사용자)  
* 전원 온 오프, 드라이버 관리, 파일관리 등 기본적인 기능 제공 및 PC시스템(파일구조 이미지 소리 등) 을 사용자가 이해할 수 있는 형태로 (가상화 공간과 같은 형태)로 보여줌  

▲ 컴퓨터 시스템에서 운영체제가 필요한 이유  


* 운영체제는 사용자의 명령어를 프로그램에 전달하거나, 그 반대로 프로그램의 명령어를 다시 CPU, RAM과 같은 연사처리에 필요한 부분, 타 프로그램에 전달하고, 나아가 사용자에게 사람이 인지할 수 있는 형태로 전달하게끔 기능하는 중간자 역할  
* 또한 컴퓨터 구동을 위한 기본적 기능(Ex. 전원, 파일관리 등)을 제공함으로써 사용자가 온전히 자신만의 프로그램 개발, 사용에 전념할 수 있도록 돕는다…만일 운영체제가 없다면 사용자는 하드에 자룔 기록하는 것 까지 모두 코드를 일일이 작성해서 진행해야 할 것

## 자료구조  
* 그래프외 트리의 차이점은?  


**그래프는 데이터의 관계도를 보임…위계관계가 아님…**


**트리와 그래프의 차이는 자료간의 모자관계를 묘사한 것인지 혹은 각 자료간의 관계도만을 도식화한 것인지의 차이**라고 볼 수 있다 트리는 시블링 노드, 차일드 노드, 루트 노드가 자기 상윗단에 간섭할 수 없거나, 시블링 노드 끼리 서로 간섭할 수 없는 위계관계가 있으나 그래프는 자료의 위계라는 개념이 없는 연결에 대한 관계도일 뿐이다…  

* 스택과 큐의 차이  

**스택:먼저 들어온 데이터가 먼저 나가는 방식**


**큐: 각 데이터가 특정 시간을 할당받아 처리되다가, 시간 내에 완료가 되지 않으면 맨 뒤로 밀려나는 방식임**  

* 알고리즘  
대문자O 표기법: “최악의 수에 대한 계산 소요시간” “ 최악의 경우의 수에 소요되는 시간 산출”  


* 배열과 연결리스트의 다른 점 / 어느 상황에서 배열보다 연결리스트를 사용하는 것이 좋은가?  
**배열 : 추가 메모리 할당 불가**   
**연결리스트 : 데이터의 삽입 및 삭제의 용이성**  

* 배열은 특정 공간의 데이터를 할당하면, 그 뒤에 추가적인 할당이 불가하며, 데이터는 순차적으로 정렬되어야 한다.  
* 연결리스트는 이와 다르며, 참조(꼬리표)를 붙여 순차적, 역순, 데이터 앞뒤, 순환의 방시으로 데이터 검색이 가능하며, 메모리 추가 할당과 데이터 삽입 삭제에 있어서 배열보다 더 유연하다. 때문에 구동속도는 더 느리다  
* 배열은 빠른 구동속도를 요하는 게임과 같은 프로그램, 혹은 적은 시스템 리소스 환경에서 연결리스트보다 더욱 적합하다.
