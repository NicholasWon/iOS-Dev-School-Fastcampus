##20170209#

스택
라스트 인 퍼스트 아웃으로 되어 있음

Ex. UINavigation Control …”설정에서 볼 수 있는 뒤로가기 스와이프 기능”…==“뷰를 계속 쌓아올리는 것”

링크드 리스트를 활용한 구현 : Stack
· Push 메소드
· Pop 메소드
· isEmpty

·· 괄호검사에서의 스택 구조
{A[(1+1) +4] = 0 }
여는 괄호들을 스택에 넣고, 닫는 괄호가 입력되면 가장 나중에 스택에 들어간 괄호와 대조 —> “식이 맞게 쓰여 있는지 컴파일러가 확인”

큐
퍼스트 인 퍼스트 아웃 구조
“대기한다는 개념이 있으며, 순서에 따라 처리하는 개념”
· 풋(큐)메소드
· 겟(디 큐) 메소드

Ex. 디스패치 큐

[정렬알고리즘]

정렬알고리즘의 종류

“개발자의 기본소양” “힙정렬까지는 어떻게 돌아가는지 알아야 함” “ios개발자에게 가장 많이 묻는 것이 GCD, 정렬알고리즘의 이해, 스택 큐”

정렬알고리즘의 효율
· 비교연산의 횟수와 이동연산의 횟수를 통해 효율을 측정
1.단순 비효율 정렬 :  삽입정렬, 선택정렬, 버블정렬
2.복잡 효율 정렬 : 합병정렬, 퀵 정렬, 힙 정렬, 기수 정렬

알고리즘복잡도
· 가장 최악의 경우에 걸리는 시간…시간은 비교연산의 횟수와 이동연산의 횟수를 통해 산출
· Big O 표기법으로 표기…O(n)…”n번 검사, 비교하면 원하는 데이터를 찾을 수 있다”, O(n logn)…”10000번이라고 가정하고, 40000의 시간동안 검사, 비교하면 원하는 데이터를 찾을 수 있다.
· small o…”최선의 경우일 때 데이터 검사시 걸리는 시간”
7 6 5 4 3 2 1

단순 비효율 정렬 알고리즘 종류

· 선택정렬
·· 가장 쉬운 정렬방법
·· 모든 데이터를 읽고, 리스트의 데이터중 가장 작은 데이터 순으로 앞쪽에 정렬하는 방식…다시 모든 데이터 읽기, 정렬하기의 반복
·· O(n^2) == 최악의 경우…n의 제곱번 검사해야 함

· 삽입정렬
·· 데이터의 비교에 따라 적절한 자리에 삽입하는 방식
·· 손안의 카드를 정렬시키는 것과 같은 방법
·· 데이터들을 읽으면서, 원하는 위치를 찾는 것
·· O(n^2) == 최악의 경우…n의 제곱번 검사해야 함

· 버블정렬
·· 인접한 데이터와 비교하여 정렬
·· 리스트의 왼쪽에서 오른쪽까지 한번 비교, 교환 과정이 완료되면, 가장 큰 수가 오른쪽 끝으로 이동함
·· 모든 숫자가 정렬될 때 까지 실행

[복잡 효율 정렬 알고리즘]
· Divide and Conquer Algorithms
·· 기본전제
“문제를 해결이 가능한 정도까지 쪼갠다”
“해결한 다음에 문제들을 다시 합친다”
“다시 합치면 해결이 가능할 정도로 쉬운 문제가 되거나 해결되어 있다”
·· 보통 재귀함수를 통해 자연스럽게 구현한다
··· 재귀함수의 특징 : CPU에 매우 많은 부하를 준다

· Quick Sort
·· 피벗:맨 앞이나 맨 뒷 숫자로 정한다
·· Merge Sort에 비해서 빠르다…
